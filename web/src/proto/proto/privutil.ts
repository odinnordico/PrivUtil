// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.11.0
//   protoc               v3.21.12
// source: proto/privutil.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "privutil";

export enum DataFormat {
  JSON = 0,
  YAML = 1,
  XML = 2,
  UNRECOGNIZED = -1,
}

export function dataFormatFromJSON(object: any): DataFormat {
  switch (object) {
    case 0:
    case "JSON":
      return DataFormat.JSON;
    case 1:
    case "YAML":
      return DataFormat.YAML;
    case 2:
    case "XML":
      return DataFormat.XML;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DataFormat.UNRECOGNIZED;
  }
}

export function dataFormatToJSON(object: DataFormat): string {
  switch (object) {
    case DataFormat.JSON:
      return "JSON";
    case DataFormat.YAML:
      return "YAML";
    case DataFormat.XML:
      return "XML";
    case DataFormat.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum TextAction {
  SORT_AZ = 0,
  SORT_ZA = 1,
  SORT_NUMERIC = 2,
  REVERSE = 3,
  DEDUPE = 4,
  REMOVE_EMPTY = 5,
  TRIM = 6,
  UNRECOGNIZED = -1,
}

export function textActionFromJSON(object: any): TextAction {
  switch (object) {
    case 0:
    case "SORT_AZ":
      return TextAction.SORT_AZ;
    case 1:
    case "SORT_ZA":
      return TextAction.SORT_ZA;
    case 2:
    case "SORT_NUMERIC":
      return TextAction.SORT_NUMERIC;
    case 3:
    case "REVERSE":
      return TextAction.REVERSE;
    case 4:
    case "DEDUPE":
      return TextAction.DEDUPE;
    case 5:
    case "REMOVE_EMPTY":
      return TextAction.REMOVE_EMPTY;
    case 6:
    case "TRIM":
      return TextAction.TRIM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TextAction.UNRECOGNIZED;
  }
}

export function textActionToJSON(object: TextAction): string {
  switch (object) {
    case TextAction.SORT_AZ:
      return "SORT_AZ";
    case TextAction.SORT_ZA:
      return "SORT_ZA";
    case TextAction.SORT_NUMERIC:
      return "SORT_NUMERIC";
    case TextAction.REVERSE:
      return "REVERSE";
    case TextAction.DEDUPE:
      return "DEDUPE";
    case TextAction.REMOVE_EMPTY:
      return "REMOVE_EMPTY";
    case TextAction.TRIM:
      return "TRIM";
    case TextAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DiffRequest {
  text1: string;
  text2: string;
}

export interface DiffResponse {
  diffHtml: string;
}

export interface Base64Request {
  text: string;
}

export interface Base64Response {
  text: string;
  error: string;
}

export interface JsonFormatRequest {
  text: string;
  /** "2", "4", "tab", or "min" (minify) */
  indent: string;
  sortKeys: boolean;
}

export interface JsonFormatResponse {
  text: string;
  error: string;
}

export interface ConvertRequest {
  data: string;
  sourceFormat: DataFormat;
  targetFormat: DataFormat;
}

export interface ConvertResponse {
  data: string;
  error: string;
}

export interface UuidRequest {
  hyphen: boolean;
  uppercase: boolean;
  count: number;
  /** "v1", "v4" */
  version: string;
}

export interface UuidResponse {
  uuids: string[];
}

export interface LoremRequest {
  /** "word", "sentence", "paragraph" */
  type: string;
  count: number;
}

export interface LoremResponse {
  text: string;
}

export interface HashRequest {
  text: string;
  /** "md5", "sha1", "sha256", "sha512" */
  algo: string;
}

export interface HashResponse {
  hash: string;
}

export interface TextRequest {
  text: string;
}

export interface TextResponse {
  text: string;
}

export interface TimeRequest {
  /** Can be timestamp (int string) or ISO date */
  input: string;
}

export interface TimeResponse {
  unix: number;
  utc: string;
  local: string;
  iso: string;
}

export interface JwtRequest {
  token: string;
}

export interface JwtResponse {
  header: string;
  payload: string;
  error: string;
}

export interface RegexRequest {
  pattern: string;
  text: string;
}

export interface RegexResponse {
  match: boolean;
  matches: string[];
  error: string;
}

export interface JsonToGoRequest {
  json: string;
  structName: string;
}

export interface JsonToGoResponse {
  goCode: string;
  error: string;
}

export interface CronRequest {
  expression: string;
}

export interface CronResponse {
  description: string;
  nextRuns: string;
  error: string;
}

export interface CertRequest {
  /** PEM */
  data: string;
}

export interface CertResponse {
  subject: string;
  issuer: string;
  notBefore: string;
  notAfter: string;
  sans: string[];
  error: string;
}

export interface ColorRequest {
  /** Any format */
  input: string;
}

export interface ColorResponse {
  hex: string;
  rgb: string;
  hsl: string;
  error: string;
}

export interface CaseRequest {
  text: string;
}

export interface CaseResponse {
  camel: string;
  snake: string;
  pascal: string;
  kebab: string;
  /** UPPER_SNAKE_CASE */
  constant: string;
  title: string;
  error: string;
}

export interface EscapeRequest {
  text: string;
  /** "json", "java", "sql", "html_entity" */
  mode: string;
  /** "escape", "unescape" */
  action: string;
}

export interface EscapeResponse {
  result: string;
  error: string;
}

export interface SimilarityRequest {
  text1: string;
  text2: string;
}

export interface SimilarityResponse {
  distance: number;
  /** 0.0 to 1.0 */
  similarity: number;
  error: string;
}

export interface SqlRequest {
  query: string;
}

export interface SqlResponse {
  formatted: string;
  error: string;
}

export interface IpRequest {
  cidr: string;
}

export interface IpResponse {
  network: string;
  broadcast: string;
  netmask: string;
  firstIp: string;
  lastIp: string;
  numHosts: number;
  error: string;
}

export interface TextInspectRequest {
  text: string;
}

export interface TextInspectResponse {
  charCount: number;
  wordCount: number;
  lineCount: number;
  byteCount: number;
}

export interface TextManipulateRequest {
  text: string;
  action: TextAction;
}

export interface TextManipulateResponse {
  text: string;
}

export interface PasswordRequest {
  length: number;
  uppercase: boolean;
  lowercase: boolean;
  numbers: boolean;
  symbols: boolean;
  /** Custom character set to use */
  customChars: string;
  /** Number of passwords to generate */
  count: number;
}

export interface PasswordResponse {
  passwords: string[];
  error: string;
}

function createBaseDiffRequest(): DiffRequest {
  return { text1: "", text2: "" };
}

export const DiffRequest: MessageFns<DiffRequest> = {
  encode(message: DiffRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text1 !== "") {
      writer.uint32(10).string(message.text1);
    }
    if (message.text2 !== "") {
      writer.uint32(18).string(message.text2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiffRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiffRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text1 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text2 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiffRequest {
    return {
      text1: isSet(object.text1) ? globalThis.String(object.text1) : "",
      text2: isSet(object.text2) ? globalThis.String(object.text2) : "",
    };
  },

  toJSON(message: DiffRequest): unknown {
    const obj: any = {};
    if (message.text1 !== "") {
      obj.text1 = message.text1;
    }
    if (message.text2 !== "") {
      obj.text2 = message.text2;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiffRequest>, I>>(base?: I): DiffRequest {
    return DiffRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiffRequest>, I>>(object: I): DiffRequest {
    const message = createBaseDiffRequest();
    message.text1 = object.text1 ?? "";
    message.text2 = object.text2 ?? "";
    return message;
  },
};

function createBaseDiffResponse(): DiffResponse {
  return { diffHtml: "" };
}

export const DiffResponse: MessageFns<DiffResponse> = {
  encode(message: DiffResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.diffHtml !== "") {
      writer.uint32(10).string(message.diffHtml);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiffResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiffResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.diffHtml = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiffResponse {
    return {
      diffHtml: isSet(object.diffHtml)
        ? globalThis.String(object.diffHtml)
        : isSet(object.diff_html)
        ? globalThis.String(object.diff_html)
        : "",
    };
  },

  toJSON(message: DiffResponse): unknown {
    const obj: any = {};
    if (message.diffHtml !== "") {
      obj.diffHtml = message.diffHtml;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DiffResponse>, I>>(base?: I): DiffResponse {
    return DiffResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DiffResponse>, I>>(object: I): DiffResponse {
    const message = createBaseDiffResponse();
    message.diffHtml = object.diffHtml ?? "";
    return message;
  },
};

function createBaseBase64Request(): Base64Request {
  return { text: "" };
}

export const Base64Request: MessageFns<Base64Request> = {
  encode(message: Base64Request, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Base64Request {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBase64Request();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Base64Request {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: Base64Request): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Base64Request>, I>>(base?: I): Base64Request {
    return Base64Request.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Base64Request>, I>>(object: I): Base64Request {
    const message = createBaseBase64Request();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseBase64Response(): Base64Response {
  return { text: "", error: "" };
}

export const Base64Response: MessageFns<Base64Response> = {
  encode(message: Base64Response, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Base64Response {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBase64Response();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Base64Response {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: Base64Response): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Base64Response>, I>>(base?: I): Base64Response {
    return Base64Response.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Base64Response>, I>>(object: I): Base64Response {
    const message = createBaseBase64Response();
    message.text = object.text ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseJsonFormatRequest(): JsonFormatRequest {
  return { text: "", indent: "", sortKeys: false };
}

export const JsonFormatRequest: MessageFns<JsonFormatRequest> = {
  encode(message: JsonFormatRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.indent !== "") {
      writer.uint32(18).string(message.indent);
    }
    if (message.sortKeys !== false) {
      writer.uint32(24).bool(message.sortKeys);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsonFormatRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonFormatRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.indent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sortKeys = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonFormatRequest {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      indent: isSet(object.indent) ? globalThis.String(object.indent) : "",
      sortKeys: isSet(object.sortKeys)
        ? globalThis.Boolean(object.sortKeys)
        : isSet(object.sort_keys)
        ? globalThis.Boolean(object.sort_keys)
        : false,
    };
  },

  toJSON(message: JsonFormatRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.indent !== "") {
      obj.indent = message.indent;
    }
    if (message.sortKeys !== false) {
      obj.sortKeys = message.sortKeys;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonFormatRequest>, I>>(base?: I): JsonFormatRequest {
    return JsonFormatRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonFormatRequest>, I>>(object: I): JsonFormatRequest {
    const message = createBaseJsonFormatRequest();
    message.text = object.text ?? "";
    message.indent = object.indent ?? "";
    message.sortKeys = object.sortKeys ?? false;
    return message;
  },
};

function createBaseJsonFormatResponse(): JsonFormatResponse {
  return { text: "", error: "" };
}

export const JsonFormatResponse: MessageFns<JsonFormatResponse> = {
  encode(message: JsonFormatResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsonFormatResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonFormatResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonFormatResponse {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: JsonFormatResponse): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonFormatResponse>, I>>(base?: I): JsonFormatResponse {
    return JsonFormatResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonFormatResponse>, I>>(object: I): JsonFormatResponse {
    const message = createBaseJsonFormatResponse();
    message.text = object.text ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseConvertRequest(): ConvertRequest {
  return { data: "", sourceFormat: 0, targetFormat: 0 };
}

export const ConvertRequest: MessageFns<ConvertRequest> = {
  encode(message: ConvertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    if (message.sourceFormat !== 0) {
      writer.uint32(16).int32(message.sourceFormat);
    }
    if (message.targetFormat !== 0) {
      writer.uint32(24).int32(message.targetFormat);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConvertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConvertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sourceFormat = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.targetFormat = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConvertRequest {
    return {
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      sourceFormat: isSet(object.sourceFormat)
        ? dataFormatFromJSON(object.sourceFormat)
        : isSet(object.source_format)
        ? dataFormatFromJSON(object.source_format)
        : 0,
      targetFormat: isSet(object.targetFormat)
        ? dataFormatFromJSON(object.targetFormat)
        : isSet(object.target_format)
        ? dataFormatFromJSON(object.target_format)
        : 0,
    };
  },

  toJSON(message: ConvertRequest): unknown {
    const obj: any = {};
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.sourceFormat !== 0) {
      obj.sourceFormat = dataFormatToJSON(message.sourceFormat);
    }
    if (message.targetFormat !== 0) {
      obj.targetFormat = dataFormatToJSON(message.targetFormat);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConvertRequest>, I>>(base?: I): ConvertRequest {
    return ConvertRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConvertRequest>, I>>(object: I): ConvertRequest {
    const message = createBaseConvertRequest();
    message.data = object.data ?? "";
    message.sourceFormat = object.sourceFormat ?? 0;
    message.targetFormat = object.targetFormat ?? 0;
    return message;
  },
};

function createBaseConvertResponse(): ConvertResponse {
  return { data: "", error: "" };
}

export const ConvertResponse: MessageFns<ConvertResponse> = {
  encode(message: ConvertResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConvertResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConvertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConvertResponse {
    return {
      data: isSet(object.data) ? globalThis.String(object.data) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ConvertResponse): unknown {
    const obj: any = {};
    if (message.data !== "") {
      obj.data = message.data;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConvertResponse>, I>>(base?: I): ConvertResponse {
    return ConvertResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConvertResponse>, I>>(object: I): ConvertResponse {
    const message = createBaseConvertResponse();
    message.data = object.data ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseUuidRequest(): UuidRequest {
  return { hyphen: false, uppercase: false, count: 0, version: "" };
}

export const UuidRequest: MessageFns<UuidRequest> = {
  encode(message: UuidRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hyphen !== false) {
      writer.uint32(8).bool(message.hyphen);
    }
    if (message.uppercase !== false) {
      writer.uint32(16).bool(message.uppercase);
    }
    if (message.count !== 0) {
      writer.uint32(24).int32(message.count);
    }
    if (message.version !== "") {
      writer.uint32(34).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UuidRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUuidRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hyphen = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uppercase = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UuidRequest {
    return {
      hyphen: isSet(object.hyphen) ? globalThis.Boolean(object.hyphen) : false,
      uppercase: isSet(object.uppercase) ? globalThis.Boolean(object.uppercase) : false,
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: UuidRequest): unknown {
    const obj: any = {};
    if (message.hyphen !== false) {
      obj.hyphen = message.hyphen;
    }
    if (message.uppercase !== false) {
      obj.uppercase = message.uppercase;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UuidRequest>, I>>(base?: I): UuidRequest {
    return UuidRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UuidRequest>, I>>(object: I): UuidRequest {
    const message = createBaseUuidRequest();
    message.hyphen = object.hyphen ?? false;
    message.uppercase = object.uppercase ?? false;
    message.count = object.count ?? 0;
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseUuidResponse(): UuidResponse {
  return { uuids: [] };
}

export const UuidResponse: MessageFns<UuidResponse> = {
  encode(message: UuidResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.uuids) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UuidResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUuidResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uuids.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UuidResponse {
    return { uuids: globalThis.Array.isArray(object?.uuids) ? object.uuids.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: UuidResponse): unknown {
    const obj: any = {};
    if (message.uuids?.length) {
      obj.uuids = message.uuids;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UuidResponse>, I>>(base?: I): UuidResponse {
    return UuidResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UuidResponse>, I>>(object: I): UuidResponse {
    const message = createBaseUuidResponse();
    message.uuids = object.uuids?.map((e) => e) || [];
    return message;
  },
};

function createBaseLoremRequest(): LoremRequest {
  return { type: "", count: 0 };
}

export const LoremRequest: MessageFns<LoremRequest> = {
  encode(message: LoremRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.count !== 0) {
      writer.uint32(16).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoremRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoremRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoremRequest {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: LoremRequest): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoremRequest>, I>>(base?: I): LoremRequest {
    return LoremRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoremRequest>, I>>(object: I): LoremRequest {
    const message = createBaseLoremRequest();
    message.type = object.type ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBaseLoremResponse(): LoremResponse {
  return { text: "" };
}

export const LoremResponse: MessageFns<LoremResponse> = {
  encode(message: LoremResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoremResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoremResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoremResponse {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: LoremResponse): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoremResponse>, I>>(base?: I): LoremResponse {
    return LoremResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoremResponse>, I>>(object: I): LoremResponse {
    const message = createBaseLoremResponse();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseHashRequest(): HashRequest {
  return { text: "", algo: "" };
}

export const HashRequest: MessageFns<HashRequest> = {
  encode(message: HashRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.algo !== "") {
      writer.uint32(18).string(message.algo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HashRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashRequest {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      algo: isSet(object.algo) ? globalThis.String(object.algo) : "",
    };
  },

  toJSON(message: HashRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.algo !== "") {
      obj.algo = message.algo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HashRequest>, I>>(base?: I): HashRequest {
    return HashRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HashRequest>, I>>(object: I): HashRequest {
    const message = createBaseHashRequest();
    message.text = object.text ?? "";
    message.algo = object.algo ?? "";
    return message;
  },
};

function createBaseHashResponse(): HashResponse {
  return { hash: "" };
}

export const HashResponse: MessageFns<HashResponse> = {
  encode(message: HashResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hash !== "") {
      writer.uint32(10).string(message.hash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HashResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHashResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HashResponse {
    return { hash: isSet(object.hash) ? globalThis.String(object.hash) : "" };
  },

  toJSON(message: HashResponse): unknown {
    const obj: any = {};
    if (message.hash !== "") {
      obj.hash = message.hash;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HashResponse>, I>>(base?: I): HashResponse {
    return HashResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HashResponse>, I>>(object: I): HashResponse {
    const message = createBaseHashResponse();
    message.hash = object.hash ?? "";
    return message;
  },
};

function createBaseTextRequest(): TextRequest {
  return { text: "" };
}

export const TextRequest: MessageFns<TextRequest> = {
  encode(message: TextRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextRequest {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: TextRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextRequest>, I>>(base?: I): TextRequest {
    return TextRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextRequest>, I>>(object: I): TextRequest {
    const message = createBaseTextRequest();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseTextResponse(): TextResponse {
  return { text: "" };
}

export const TextResponse: MessageFns<TextResponse> = {
  encode(message: TextResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextResponse {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: TextResponse): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextResponse>, I>>(base?: I): TextResponse {
    return TextResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextResponse>, I>>(object: I): TextResponse {
    const message = createBaseTextResponse();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseTimeRequest(): TimeRequest {
  return { input: "" };
}

export const TimeRequest: MessageFns<TimeRequest> = {
  encode(message: TimeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== "") {
      writer.uint32(10).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeRequest {
    return { input: isSet(object.input) ? globalThis.String(object.input) : "" };
  },

  toJSON(message: TimeRequest): unknown {
    const obj: any = {};
    if (message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeRequest>, I>>(base?: I): TimeRequest {
    return TimeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeRequest>, I>>(object: I): TimeRequest {
    const message = createBaseTimeRequest();
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseTimeResponse(): TimeResponse {
  return { unix: 0, utc: "", local: "", iso: "" };
}

export const TimeResponse: MessageFns<TimeResponse> = {
  encode(message: TimeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.unix !== 0) {
      writer.uint32(8).int64(message.unix);
    }
    if (message.utc !== "") {
      writer.uint32(18).string(message.utc);
    }
    if (message.local !== "") {
      writer.uint32(26).string(message.local);
    }
    if (message.iso !== "") {
      writer.uint32(34).string(message.iso);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.unix = longToNumber(reader.int64());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.utc = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.local = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.iso = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeResponse {
    return {
      unix: isSet(object.unix) ? globalThis.Number(object.unix) : 0,
      utc: isSet(object.utc) ? globalThis.String(object.utc) : "",
      local: isSet(object.local) ? globalThis.String(object.local) : "",
      iso: isSet(object.iso) ? globalThis.String(object.iso) : "",
    };
  },

  toJSON(message: TimeResponse): unknown {
    const obj: any = {};
    if (message.unix !== 0) {
      obj.unix = Math.round(message.unix);
    }
    if (message.utc !== "") {
      obj.utc = message.utc;
    }
    if (message.local !== "") {
      obj.local = message.local;
    }
    if (message.iso !== "") {
      obj.iso = message.iso;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeResponse>, I>>(base?: I): TimeResponse {
    return TimeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeResponse>, I>>(object: I): TimeResponse {
    const message = createBaseTimeResponse();
    message.unix = object.unix ?? 0;
    message.utc = object.utc ?? "";
    message.local = object.local ?? "";
    message.iso = object.iso ?? "";
    return message;
  },
};

function createBaseJwtRequest(): JwtRequest {
  return { token: "" };
}

export const JwtRequest: MessageFns<JwtRequest> = {
  encode(message: JwtRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtRequest {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: JwtRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtRequest>, I>>(base?: I): JwtRequest {
    return JwtRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtRequest>, I>>(object: I): JwtRequest {
    const message = createBaseJwtRequest();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseJwtResponse(): JwtResponse {
  return { header: "", payload: "", error: "" };
}

export const JwtResponse: MessageFns<JwtResponse> = {
  encode(message: JwtResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.header !== "") {
      writer.uint32(10).string(message.header);
    }
    if (message.payload !== "") {
      writer.uint32(18).string(message.payload);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JwtResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJwtResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.header = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JwtResponse {
    return {
      header: isSet(object.header) ? globalThis.String(object.header) : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: JwtResponse): unknown {
    const obj: any = {};
    if (message.header !== "") {
      obj.header = message.header;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JwtResponse>, I>>(base?: I): JwtResponse {
    return JwtResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JwtResponse>, I>>(object: I): JwtResponse {
    const message = createBaseJwtResponse();
    message.header = object.header ?? "";
    message.payload = object.payload ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseRegexRequest(): RegexRequest {
  return { pattern: "", text: "" };
}

export const RegexRequest: MessageFns<RegexRequest> = {
  encode(message: RegexRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pattern !== "") {
      writer.uint32(10).string(message.pattern);
    }
    if (message.text !== "") {
      writer.uint32(18).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegexRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegexRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pattern = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegexRequest {
    return {
      pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
      text: isSet(object.text) ? globalThis.String(object.text) : "",
    };
  },

  toJSON(message: RegexRequest): unknown {
    const obj: any = {};
    if (message.pattern !== "") {
      obj.pattern = message.pattern;
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegexRequest>, I>>(base?: I): RegexRequest {
    return RegexRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegexRequest>, I>>(object: I): RegexRequest {
    const message = createBaseRegexRequest();
    message.pattern = object.pattern ?? "";
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseRegexResponse(): RegexResponse {
  return { match: false, matches: [], error: "" };
}

export const RegexResponse: MessageFns<RegexResponse> = {
  encode(message: RegexResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.match !== false) {
      writer.uint32(8).bool(message.match);
    }
    for (const v of message.matches) {
      writer.uint32(18).string(v!);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegexResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegexResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.match = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.matches.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegexResponse {
    return {
      match: isSet(object.match) ? globalThis.Boolean(object.match) : false,
      matches: globalThis.Array.isArray(object?.matches) ? object.matches.map((e: any) => globalThis.String(e)) : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: RegexResponse): unknown {
    const obj: any = {};
    if (message.match !== false) {
      obj.match = message.match;
    }
    if (message.matches?.length) {
      obj.matches = message.matches;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegexResponse>, I>>(base?: I): RegexResponse {
    return RegexResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegexResponse>, I>>(object: I): RegexResponse {
    const message = createBaseRegexResponse();
    message.match = object.match ?? false;
    message.matches = object.matches?.map((e) => e) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseJsonToGoRequest(): JsonToGoRequest {
  return { json: "", structName: "" };
}

export const JsonToGoRequest: MessageFns<JsonToGoRequest> = {
  encode(message: JsonToGoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.json !== "") {
      writer.uint32(10).string(message.json);
    }
    if (message.structName !== "") {
      writer.uint32(18).string(message.structName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsonToGoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonToGoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.json = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.structName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonToGoRequest {
    return {
      json: isSet(object.json) ? globalThis.String(object.json) : "",
      structName: isSet(object.structName)
        ? globalThis.String(object.structName)
        : isSet(object.struct_name)
        ? globalThis.String(object.struct_name)
        : "",
    };
  },

  toJSON(message: JsonToGoRequest): unknown {
    const obj: any = {};
    if (message.json !== "") {
      obj.json = message.json;
    }
    if (message.structName !== "") {
      obj.structName = message.structName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonToGoRequest>, I>>(base?: I): JsonToGoRequest {
    return JsonToGoRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonToGoRequest>, I>>(object: I): JsonToGoRequest {
    const message = createBaseJsonToGoRequest();
    message.json = object.json ?? "";
    message.structName = object.structName ?? "";
    return message;
  },
};

function createBaseJsonToGoResponse(): JsonToGoResponse {
  return { goCode: "", error: "" };
}

export const JsonToGoResponse: MessageFns<JsonToGoResponse> = {
  encode(message: JsonToGoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.goCode !== "") {
      writer.uint32(10).string(message.goCode);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JsonToGoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJsonToGoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.goCode = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JsonToGoResponse {
    return {
      goCode: isSet(object.goCode)
        ? globalThis.String(object.goCode)
        : isSet(object.go_code)
        ? globalThis.String(object.go_code)
        : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: JsonToGoResponse): unknown {
    const obj: any = {};
    if (message.goCode !== "") {
      obj.goCode = message.goCode;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JsonToGoResponse>, I>>(base?: I): JsonToGoResponse {
    return JsonToGoResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JsonToGoResponse>, I>>(object: I): JsonToGoResponse {
    const message = createBaseJsonToGoResponse();
    message.goCode = object.goCode ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCronRequest(): CronRequest {
  return { expression: "" };
}

export const CronRequest: MessageFns<CronRequest> = {
  encode(message: CronRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression !== "") {
      writer.uint32(10).string(message.expression);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.expression = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronRequest {
    return { expression: isSet(object.expression) ? globalThis.String(object.expression) : "" };
  },

  toJSON(message: CronRequest): unknown {
    const obj: any = {};
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronRequest>, I>>(base?: I): CronRequest {
    return CronRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronRequest>, I>>(object: I): CronRequest {
    const message = createBaseCronRequest();
    message.expression = object.expression ?? "";
    return message;
  },
};

function createBaseCronResponse(): CronResponse {
  return { description: "", nextRuns: "", error: "" };
}

export const CronResponse: MessageFns<CronResponse> = {
  encode(message: CronResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.description !== "") {
      writer.uint32(10).string(message.description);
    }
    if (message.nextRuns !== "") {
      writer.uint32(18).string(message.nextRuns);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CronResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCronResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nextRuns = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CronResponse {
    return {
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      nextRuns: isSet(object.nextRuns)
        ? globalThis.String(object.nextRuns)
        : isSet(object.next_runs)
        ? globalThis.String(object.next_runs)
        : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CronResponse): unknown {
    const obj: any = {};
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.nextRuns !== "") {
      obj.nextRuns = message.nextRuns;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CronResponse>, I>>(base?: I): CronResponse {
    return CronResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CronResponse>, I>>(object: I): CronResponse {
    const message = createBaseCronResponse();
    message.description = object.description ?? "";
    message.nextRuns = object.nextRuns ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCertRequest(): CertRequest {
  return { data: "" };
}

export const CertRequest: MessageFns<CertRequest> = {
  encode(message: CertRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.data !== "") {
      writer.uint32(10).string(message.data);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.data = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertRequest {
    return { data: isSet(object.data) ? globalThis.String(object.data) : "" };
  },

  toJSON(message: CertRequest): unknown {
    const obj: any = {};
    if (message.data !== "") {
      obj.data = message.data;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertRequest>, I>>(base?: I): CertRequest {
    return CertRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertRequest>, I>>(object: I): CertRequest {
    const message = createBaseCertRequest();
    message.data = object.data ?? "";
    return message;
  },
};

function createBaseCertResponse(): CertResponse {
  return { subject: "", issuer: "", notBefore: "", notAfter: "", sans: [], error: "" };
}

export const CertResponse: MessageFns<CertResponse> = {
  encode(message: CertResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.subject !== "") {
      writer.uint32(10).string(message.subject);
    }
    if (message.issuer !== "") {
      writer.uint32(18).string(message.issuer);
    }
    if (message.notBefore !== "") {
      writer.uint32(26).string(message.notBefore);
    }
    if (message.notAfter !== "") {
      writer.uint32(34).string(message.notAfter);
    }
    for (const v of message.sans) {
      writer.uint32(42).string(v!);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CertResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCertResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.subject = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.issuer = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.notBefore = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.notAfter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sans.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CertResponse {
    return {
      subject: isSet(object.subject) ? globalThis.String(object.subject) : "",
      issuer: isSet(object.issuer) ? globalThis.String(object.issuer) : "",
      notBefore: isSet(object.notBefore)
        ? globalThis.String(object.notBefore)
        : isSet(object.not_before)
        ? globalThis.String(object.not_before)
        : "",
      notAfter: isSet(object.notAfter)
        ? globalThis.String(object.notAfter)
        : isSet(object.not_after)
        ? globalThis.String(object.not_after)
        : "",
      sans: globalThis.Array.isArray(object?.sans) ? object.sans.map((e: any) => globalThis.String(e)) : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CertResponse): unknown {
    const obj: any = {};
    if (message.subject !== "") {
      obj.subject = message.subject;
    }
    if (message.issuer !== "") {
      obj.issuer = message.issuer;
    }
    if (message.notBefore !== "") {
      obj.notBefore = message.notBefore;
    }
    if (message.notAfter !== "") {
      obj.notAfter = message.notAfter;
    }
    if (message.sans?.length) {
      obj.sans = message.sans;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CertResponse>, I>>(base?: I): CertResponse {
    return CertResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CertResponse>, I>>(object: I): CertResponse {
    const message = createBaseCertResponse();
    message.subject = object.subject ?? "";
    message.issuer = object.issuer ?? "";
    message.notBefore = object.notBefore ?? "";
    message.notAfter = object.notAfter ?? "";
    message.sans = object.sans?.map((e) => e) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseColorRequest(): ColorRequest {
  return { input: "" };
}

export const ColorRequest: MessageFns<ColorRequest> = {
  encode(message: ColorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.input !== "") {
      writer.uint32(10).string(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColorRequest {
    return { input: isSet(object.input) ? globalThis.String(object.input) : "" };
  },

  toJSON(message: ColorRequest): unknown {
    const obj: any = {};
    if (message.input !== "") {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ColorRequest>, I>>(base?: I): ColorRequest {
    return ColorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ColorRequest>, I>>(object: I): ColorRequest {
    const message = createBaseColorRequest();
    message.input = object.input ?? "";
    return message;
  },
};

function createBaseColorResponse(): ColorResponse {
  return { hex: "", rgb: "", hsl: "", error: "" };
}

export const ColorResponse: MessageFns<ColorResponse> = {
  encode(message: ColorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hex !== "") {
      writer.uint32(10).string(message.hex);
    }
    if (message.rgb !== "") {
      writer.uint32(18).string(message.rgb);
    }
    if (message.hsl !== "") {
      writer.uint32(26).string(message.hsl);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ColorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseColorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hex = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rgb = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.hsl = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ColorResponse {
    return {
      hex: isSet(object.hex) ? globalThis.String(object.hex) : "",
      rgb: isSet(object.rgb) ? globalThis.String(object.rgb) : "",
      hsl: isSet(object.hsl) ? globalThis.String(object.hsl) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ColorResponse): unknown {
    const obj: any = {};
    if (message.hex !== "") {
      obj.hex = message.hex;
    }
    if (message.rgb !== "") {
      obj.rgb = message.rgb;
    }
    if (message.hsl !== "") {
      obj.hsl = message.hsl;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ColorResponse>, I>>(base?: I): ColorResponse {
    return ColorResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ColorResponse>, I>>(object: I): ColorResponse {
    const message = createBaseColorResponse();
    message.hex = object.hex ?? "";
    message.rgb = object.rgb ?? "";
    message.hsl = object.hsl ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCaseRequest(): CaseRequest {
  return { text: "" };
}

export const CaseRequest: MessageFns<CaseRequest> = {
  encode(message: CaseRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaseRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaseRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaseRequest {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: CaseRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaseRequest>, I>>(base?: I): CaseRequest {
    return CaseRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaseRequest>, I>>(object: I): CaseRequest {
    const message = createBaseCaseRequest();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseCaseResponse(): CaseResponse {
  return { camel: "", snake: "", pascal: "", kebab: "", constant: "", title: "", error: "" };
}

export const CaseResponse: MessageFns<CaseResponse> = {
  encode(message: CaseResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.camel !== "") {
      writer.uint32(10).string(message.camel);
    }
    if (message.snake !== "") {
      writer.uint32(18).string(message.snake);
    }
    if (message.pascal !== "") {
      writer.uint32(26).string(message.pascal);
    }
    if (message.kebab !== "") {
      writer.uint32(34).string(message.kebab);
    }
    if (message.constant !== "") {
      writer.uint32(42).string(message.constant);
    }
    if (message.title !== "") {
      writer.uint32(50).string(message.title);
    }
    if (message.error !== "") {
      writer.uint32(58).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CaseResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCaseResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.camel = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.snake = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pascal = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.kebab = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.constant = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CaseResponse {
    return {
      camel: isSet(object.camel) ? globalThis.String(object.camel) : "",
      snake: isSet(object.snake) ? globalThis.String(object.snake) : "",
      pascal: isSet(object.pascal) ? globalThis.String(object.pascal) : "",
      kebab: isSet(object.kebab) ? globalThis.String(object.kebab) : "",
      constant: isSet(object.constant) ? globalThis.String(object.constant) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CaseResponse): unknown {
    const obj: any = {};
    if (message.camel !== "") {
      obj.camel = message.camel;
    }
    if (message.snake !== "") {
      obj.snake = message.snake;
    }
    if (message.pascal !== "") {
      obj.pascal = message.pascal;
    }
    if (message.kebab !== "") {
      obj.kebab = message.kebab;
    }
    if (message.constant !== "") {
      obj.constant = message.constant;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CaseResponse>, I>>(base?: I): CaseResponse {
    return CaseResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CaseResponse>, I>>(object: I): CaseResponse {
    const message = createBaseCaseResponse();
    message.camel = object.camel ?? "";
    message.snake = object.snake ?? "";
    message.pascal = object.pascal ?? "";
    message.kebab = object.kebab ?? "";
    message.constant = object.constant ?? "";
    message.title = object.title ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseEscapeRequest(): EscapeRequest {
  return { text: "", mode: "", action: "" };
}

export const EscapeRequest: MessageFns<EscapeRequest> = {
  encode(message: EscapeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.mode !== "") {
      writer.uint32(18).string(message.mode);
    }
    if (message.action !== "") {
      writer.uint32(26).string(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EscapeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEscapeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mode = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EscapeRequest {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      mode: isSet(object.mode) ? globalThis.String(object.mode) : "",
      action: isSet(object.action) ? globalThis.String(object.action) : "",
    };
  },

  toJSON(message: EscapeRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.mode !== "") {
      obj.mode = message.mode;
    }
    if (message.action !== "") {
      obj.action = message.action;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EscapeRequest>, I>>(base?: I): EscapeRequest {
    return EscapeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EscapeRequest>, I>>(object: I): EscapeRequest {
    const message = createBaseEscapeRequest();
    message.text = object.text ?? "";
    message.mode = object.mode ?? "";
    message.action = object.action ?? "";
    return message;
  },
};

function createBaseEscapeResponse(): EscapeResponse {
  return { result: "", error: "" };
}

export const EscapeResponse: MessageFns<EscapeResponse> = {
  encode(message: EscapeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.result !== "") {
      writer.uint32(10).string(message.result);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EscapeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEscapeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.result = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EscapeResponse {
    return {
      result: isSet(object.result) ? globalThis.String(object.result) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: EscapeResponse): unknown {
    const obj: any = {};
    if (message.result !== "") {
      obj.result = message.result;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EscapeResponse>, I>>(base?: I): EscapeResponse {
    return EscapeResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EscapeResponse>, I>>(object: I): EscapeResponse {
    const message = createBaseEscapeResponse();
    message.result = object.result ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseSimilarityRequest(): SimilarityRequest {
  return { text1: "", text2: "" };
}

export const SimilarityRequest: MessageFns<SimilarityRequest> = {
  encode(message: SimilarityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text1 !== "") {
      writer.uint32(10).string(message.text1);
    }
    if (message.text2 !== "") {
      writer.uint32(18).string(message.text2);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimilarityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimilarityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text1 = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.text2 = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimilarityRequest {
    return {
      text1: isSet(object.text1) ? globalThis.String(object.text1) : "",
      text2: isSet(object.text2) ? globalThis.String(object.text2) : "",
    };
  },

  toJSON(message: SimilarityRequest): unknown {
    const obj: any = {};
    if (message.text1 !== "") {
      obj.text1 = message.text1;
    }
    if (message.text2 !== "") {
      obj.text2 = message.text2;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimilarityRequest>, I>>(base?: I): SimilarityRequest {
    return SimilarityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimilarityRequest>, I>>(object: I): SimilarityRequest {
    const message = createBaseSimilarityRequest();
    message.text1 = object.text1 ?? "";
    message.text2 = object.text2 ?? "";
    return message;
  },
};

function createBaseSimilarityResponse(): SimilarityResponse {
  return { distance: 0, similarity: 0, error: "" };
}

export const SimilarityResponse: MessageFns<SimilarityResponse> = {
  encode(message: SimilarityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.distance !== 0) {
      writer.uint32(8).int32(message.distance);
    }
    if (message.similarity !== 0) {
      writer.uint32(21).float(message.similarity);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimilarityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimilarityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.distance = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 21) {
            break;
          }

          message.similarity = reader.float();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimilarityResponse {
    return {
      distance: isSet(object.distance) ? globalThis.Number(object.distance) : 0,
      similarity: isSet(object.similarity) ? globalThis.Number(object.similarity) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: SimilarityResponse): unknown {
    const obj: any = {};
    if (message.distance !== 0) {
      obj.distance = Math.round(message.distance);
    }
    if (message.similarity !== 0) {
      obj.similarity = message.similarity;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SimilarityResponse>, I>>(base?: I): SimilarityResponse {
    return SimilarityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SimilarityResponse>, I>>(object: I): SimilarityResponse {
    const message = createBaseSimilarityResponse();
    message.distance = object.distance ?? 0;
    message.similarity = object.similarity ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseSqlRequest(): SqlRequest {
  return { query: "" };
}

export const SqlRequest: MessageFns<SqlRequest> = {
  encode(message: SqlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlRequest {
    return { query: isSet(object.query) ? globalThis.String(object.query) : "" };
  },

  toJSON(message: SqlRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SqlRequest>, I>>(base?: I): SqlRequest {
    return SqlRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SqlRequest>, I>>(object: I): SqlRequest {
    const message = createBaseSqlRequest();
    message.query = object.query ?? "";
    return message;
  },
};

function createBaseSqlResponse(): SqlResponse {
  return { formatted: "", error: "" };
}

export const SqlResponse: MessageFns<SqlResponse> = {
  encode(message: SqlResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.formatted !== "") {
      writer.uint32(10).string(message.formatted);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SqlResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSqlResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.formatted = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SqlResponse {
    return {
      formatted: isSet(object.formatted) ? globalThis.String(object.formatted) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: SqlResponse): unknown {
    const obj: any = {};
    if (message.formatted !== "") {
      obj.formatted = message.formatted;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SqlResponse>, I>>(base?: I): SqlResponse {
    return SqlResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SqlResponse>, I>>(object: I): SqlResponse {
    const message = createBaseSqlResponse();
    message.formatted = object.formatted ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseIpRequest(): IpRequest {
  return { cidr: "" };
}

export const IpRequest: MessageFns<IpRequest> = {
  encode(message: IpRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cidr !== "") {
      writer.uint32(10).string(message.cidr);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cidr = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpRequest {
    return { cidr: isSet(object.cidr) ? globalThis.String(object.cidr) : "" };
  },

  toJSON(message: IpRequest): unknown {
    const obj: any = {};
    if (message.cidr !== "") {
      obj.cidr = message.cidr;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpRequest>, I>>(base?: I): IpRequest {
    return IpRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpRequest>, I>>(object: I): IpRequest {
    const message = createBaseIpRequest();
    message.cidr = object.cidr ?? "";
    return message;
  },
};

function createBaseIpResponse(): IpResponse {
  return { network: "", broadcast: "", netmask: "", firstIp: "", lastIp: "", numHosts: 0, error: "" };
}

export const IpResponse: MessageFns<IpResponse> = {
  encode(message: IpResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.network !== "") {
      writer.uint32(10).string(message.network);
    }
    if (message.broadcast !== "") {
      writer.uint32(18).string(message.broadcast);
    }
    if (message.netmask !== "") {
      writer.uint32(26).string(message.netmask);
    }
    if (message.firstIp !== "") {
      writer.uint32(34).string(message.firstIp);
    }
    if (message.lastIp !== "") {
      writer.uint32(42).string(message.lastIp);
    }
    if (message.numHosts !== 0) {
      writer.uint32(48).int64(message.numHosts);
    }
    if (message.error !== "") {
      writer.uint32(58).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IpResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIpResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.network = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.broadcast = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.netmask = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.firstIp = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.lastIp = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.numHosts = longToNumber(reader.int64());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IpResponse {
    return {
      network: isSet(object.network) ? globalThis.String(object.network) : "",
      broadcast: isSet(object.broadcast) ? globalThis.String(object.broadcast) : "",
      netmask: isSet(object.netmask) ? globalThis.String(object.netmask) : "",
      firstIp: isSet(object.firstIp)
        ? globalThis.String(object.firstIp)
        : isSet(object.first_ip)
        ? globalThis.String(object.first_ip)
        : "",
      lastIp: isSet(object.lastIp)
        ? globalThis.String(object.lastIp)
        : isSet(object.last_ip)
        ? globalThis.String(object.last_ip)
        : "",
      numHosts: isSet(object.numHosts)
        ? globalThis.Number(object.numHosts)
        : isSet(object.num_hosts)
        ? globalThis.Number(object.num_hosts)
        : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: IpResponse): unknown {
    const obj: any = {};
    if (message.network !== "") {
      obj.network = message.network;
    }
    if (message.broadcast !== "") {
      obj.broadcast = message.broadcast;
    }
    if (message.netmask !== "") {
      obj.netmask = message.netmask;
    }
    if (message.firstIp !== "") {
      obj.firstIp = message.firstIp;
    }
    if (message.lastIp !== "") {
      obj.lastIp = message.lastIp;
    }
    if (message.numHosts !== 0) {
      obj.numHosts = Math.round(message.numHosts);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IpResponse>, I>>(base?: I): IpResponse {
    return IpResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IpResponse>, I>>(object: I): IpResponse {
    const message = createBaseIpResponse();
    message.network = object.network ?? "";
    message.broadcast = object.broadcast ?? "";
    message.netmask = object.netmask ?? "";
    message.firstIp = object.firstIp ?? "";
    message.lastIp = object.lastIp ?? "";
    message.numHosts = object.numHosts ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseTextInspectRequest(): TextInspectRequest {
  return { text: "" };
}

export const TextInspectRequest: MessageFns<TextInspectRequest> = {
  encode(message: TextInspectRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextInspectRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextInspectRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextInspectRequest {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: TextInspectRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextInspectRequest>, I>>(base?: I): TextInspectRequest {
    return TextInspectRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextInspectRequest>, I>>(object: I): TextInspectRequest {
    const message = createBaseTextInspectRequest();
    message.text = object.text ?? "";
    return message;
  },
};

function createBaseTextInspectResponse(): TextInspectResponse {
  return { charCount: 0, wordCount: 0, lineCount: 0, byteCount: 0 };
}

export const TextInspectResponse: MessageFns<TextInspectResponse> = {
  encode(message: TextInspectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.charCount !== 0) {
      writer.uint32(8).int32(message.charCount);
    }
    if (message.wordCount !== 0) {
      writer.uint32(16).int32(message.wordCount);
    }
    if (message.lineCount !== 0) {
      writer.uint32(24).int32(message.lineCount);
    }
    if (message.byteCount !== 0) {
      writer.uint32(32).int32(message.byteCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextInspectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextInspectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.charCount = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.wordCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lineCount = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.byteCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextInspectResponse {
    return {
      charCount: isSet(object.charCount)
        ? globalThis.Number(object.charCount)
        : isSet(object.char_count)
        ? globalThis.Number(object.char_count)
        : 0,
      wordCount: isSet(object.wordCount)
        ? globalThis.Number(object.wordCount)
        : isSet(object.word_count)
        ? globalThis.Number(object.word_count)
        : 0,
      lineCount: isSet(object.lineCount)
        ? globalThis.Number(object.lineCount)
        : isSet(object.line_count)
        ? globalThis.Number(object.line_count)
        : 0,
      byteCount: isSet(object.byteCount)
        ? globalThis.Number(object.byteCount)
        : isSet(object.byte_count)
        ? globalThis.Number(object.byte_count)
        : 0,
    };
  },

  toJSON(message: TextInspectResponse): unknown {
    const obj: any = {};
    if (message.charCount !== 0) {
      obj.charCount = Math.round(message.charCount);
    }
    if (message.wordCount !== 0) {
      obj.wordCount = Math.round(message.wordCount);
    }
    if (message.lineCount !== 0) {
      obj.lineCount = Math.round(message.lineCount);
    }
    if (message.byteCount !== 0) {
      obj.byteCount = Math.round(message.byteCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextInspectResponse>, I>>(base?: I): TextInspectResponse {
    return TextInspectResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextInspectResponse>, I>>(object: I): TextInspectResponse {
    const message = createBaseTextInspectResponse();
    message.charCount = object.charCount ?? 0;
    message.wordCount = object.wordCount ?? 0;
    message.lineCount = object.lineCount ?? 0;
    message.byteCount = object.byteCount ?? 0;
    return message;
  },
};

function createBaseTextManipulateRequest(): TextManipulateRequest {
  return { text: "", action: 0 };
}

export const TextManipulateRequest: MessageFns<TextManipulateRequest> = {
  encode(message: TextManipulateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    if (message.action !== 0) {
      writer.uint32(16).int32(message.action);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextManipulateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextManipulateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextManipulateRequest {
    return {
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      action: isSet(object.action) ? textActionFromJSON(object.action) : 0,
    };
  },

  toJSON(message: TextManipulateRequest): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.action !== 0) {
      obj.action = textActionToJSON(message.action);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextManipulateRequest>, I>>(base?: I): TextManipulateRequest {
    return TextManipulateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextManipulateRequest>, I>>(object: I): TextManipulateRequest {
    const message = createBaseTextManipulateRequest();
    message.text = object.text ?? "";
    message.action = object.action ?? 0;
    return message;
  },
};

function createBaseTextManipulateResponse(): TextManipulateResponse {
  return { text: "" };
}

export const TextManipulateResponse: MessageFns<TextManipulateResponse> = {
  encode(message: TextManipulateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.text !== "") {
      writer.uint32(10).string(message.text);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TextManipulateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTextManipulateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.text = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TextManipulateResponse {
    return { text: isSet(object.text) ? globalThis.String(object.text) : "" };
  },

  toJSON(message: TextManipulateResponse): unknown {
    const obj: any = {};
    if (message.text !== "") {
      obj.text = message.text;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TextManipulateResponse>, I>>(base?: I): TextManipulateResponse {
    return TextManipulateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TextManipulateResponse>, I>>(object: I): TextManipulateResponse {
    const message = createBaseTextManipulateResponse();
    message.text = object.text ?? "";
    return message;
  },
};

function createBasePasswordRequest(): PasswordRequest {
  return { length: 0, uppercase: false, lowercase: false, numbers: false, symbols: false, customChars: "", count: 0 };
}

export const PasswordRequest: MessageFns<PasswordRequest> = {
  encode(message: PasswordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.length !== 0) {
      writer.uint32(8).int32(message.length);
    }
    if (message.uppercase !== false) {
      writer.uint32(16).bool(message.uppercase);
    }
    if (message.lowercase !== false) {
      writer.uint32(24).bool(message.lowercase);
    }
    if (message.numbers !== false) {
      writer.uint32(32).bool(message.numbers);
    }
    if (message.symbols !== false) {
      writer.uint32(40).bool(message.symbols);
    }
    if (message.customChars !== "") {
      writer.uint32(50).string(message.customChars);
    }
    if (message.count !== 0) {
      writer.uint32(56).int32(message.count);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PasswordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasswordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.length = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.uppercase = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.lowercase = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.numbers = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.symbols = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.customChars = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.count = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PasswordRequest {
    return {
      length: isSet(object.length) ? globalThis.Number(object.length) : 0,
      uppercase: isSet(object.uppercase) ? globalThis.Boolean(object.uppercase) : false,
      lowercase: isSet(object.lowercase) ? globalThis.Boolean(object.lowercase) : false,
      numbers: isSet(object.numbers) ? globalThis.Boolean(object.numbers) : false,
      symbols: isSet(object.symbols) ? globalThis.Boolean(object.symbols) : false,
      customChars: isSet(object.customChars)
        ? globalThis.String(object.customChars)
        : isSet(object.custom_chars)
        ? globalThis.String(object.custom_chars)
        : "",
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
    };
  },

  toJSON(message: PasswordRequest): unknown {
    const obj: any = {};
    if (message.length !== 0) {
      obj.length = Math.round(message.length);
    }
    if (message.uppercase !== false) {
      obj.uppercase = message.uppercase;
    }
    if (message.lowercase !== false) {
      obj.lowercase = message.lowercase;
    }
    if (message.numbers !== false) {
      obj.numbers = message.numbers;
    }
    if (message.symbols !== false) {
      obj.symbols = message.symbols;
    }
    if (message.customChars !== "") {
      obj.customChars = message.customChars;
    }
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PasswordRequest>, I>>(base?: I): PasswordRequest {
    return PasswordRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PasswordRequest>, I>>(object: I): PasswordRequest {
    const message = createBasePasswordRequest();
    message.length = object.length ?? 0;
    message.uppercase = object.uppercase ?? false;
    message.lowercase = object.lowercase ?? false;
    message.numbers = object.numbers ?? false;
    message.symbols = object.symbols ?? false;
    message.customChars = object.customChars ?? "";
    message.count = object.count ?? 0;
    return message;
  },
};

function createBasePasswordResponse(): PasswordResponse {
  return { passwords: [], error: "" };
}

export const PasswordResponse: MessageFns<PasswordResponse> = {
  encode(message: PasswordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.passwords) {
      writer.uint32(10).string(v!);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PasswordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePasswordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.passwords.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PasswordResponse {
    return {
      passwords: globalThis.Array.isArray(object?.passwords)
        ? object.passwords.map((e: any) => globalThis.String(e))
        : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: PasswordResponse): unknown {
    const obj: any = {};
    if (message.passwords?.length) {
      obj.passwords = message.passwords;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PasswordResponse>, I>>(base?: I): PasswordResponse {
    return PasswordResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PasswordResponse>, I>>(object: I): PasswordResponse {
    const message = createBasePasswordResponse();
    message.passwords = object.passwords?.map((e) => e) || [];
    message.error = object.error ?? "";
    return message;
  },
};

export type PrivUtilServiceDefinition = typeof PrivUtilServiceDefinition;
export const PrivUtilServiceDefinition = {
  name: "PrivUtilService",
  fullName: "privutil.PrivUtilService",
  methods: {
    diff: {
      name: "Diff",
      requestType: DiffRequest,
      requestStream: false,
      responseType: DiffResponse,
      responseStream: false,
      options: {},
    },
    base64Encode: {
      name: "Base64Encode",
      requestType: Base64Request,
      requestStream: false,
      responseType: Base64Response,
      responseStream: false,
      options: {},
    },
    base64Decode: {
      name: "Base64Decode",
      requestType: Base64Request,
      requestStream: false,
      responseType: Base64Response,
      responseStream: false,
      options: {},
    },
    jsonFormat: {
      name: "JsonFormat",
      requestType: JsonFormatRequest,
      requestStream: false,
      responseType: JsonFormatResponse,
      responseStream: false,
      options: {},
    },
    convert: {
      name: "Convert",
      requestType: ConvertRequest,
      requestStream: false,
      responseType: ConvertResponse,
      responseStream: false,
      options: {},
    },
    generateUuid: {
      name: "GenerateUuid",
      requestType: UuidRequest,
      requestStream: false,
      responseType: UuidResponse,
      responseStream: false,
      options: {},
    },
    generateLorem: {
      name: "GenerateLorem",
      requestType: LoremRequest,
      requestStream: false,
      responseType: LoremResponse,
      responseStream: false,
      options: {},
    },
    calculateHash: {
      name: "CalculateHash",
      requestType: HashRequest,
      requestStream: false,
      responseType: HashResponse,
      responseStream: false,
      options: {},
    },
    textInspect: {
      name: "TextInspect",
      requestType: TextInspectRequest,
      requestStream: false,
      responseType: TextInspectResponse,
      responseStream: false,
      options: {},
    },
    textManipulate: {
      name: "TextManipulate",
      requestType: TextManipulateRequest,
      requestStream: false,
      responseType: TextManipulateResponse,
      responseStream: false,
      options: {},
    },
    urlEncode: {
      name: "UrlEncode",
      requestType: TextRequest,
      requestStream: false,
      responseType: TextResponse,
      responseStream: false,
      options: {},
    },
    urlDecode: {
      name: "UrlDecode",
      requestType: TextRequest,
      requestStream: false,
      responseType: TextResponse,
      responseStream: false,
      options: {},
    },
    htmlEncode: {
      name: "HtmlEncode",
      requestType: TextRequest,
      requestStream: false,
      responseType: TextResponse,
      responseStream: false,
      options: {},
    },
    htmlDecode: {
      name: "HtmlDecode",
      requestType: TextRequest,
      requestStream: false,
      responseType: TextResponse,
      responseStream: false,
      options: {},
    },
    timeConvert: {
      name: "TimeConvert",
      requestType: TimeRequest,
      requestStream: false,
      responseType: TimeResponse,
      responseStream: false,
      options: {},
    },
    jwtDecode: {
      name: "JwtDecode",
      requestType: JwtRequest,
      requestStream: false,
      responseType: JwtResponse,
      responseStream: false,
      options: {},
    },
    regexTest: {
      name: "RegexTest",
      requestType: RegexRequest,
      requestStream: false,
      responseType: RegexResponse,
      responseStream: false,
      options: {},
    },
    jsonToGo: {
      name: "JsonToGo",
      requestType: JsonToGoRequest,
      requestStream: false,
      responseType: JsonToGoResponse,
      responseStream: false,
      options: {},
    },
    cronExplain: {
      name: "CronExplain",
      requestType: CronRequest,
      requestStream: false,
      responseType: CronResponse,
      responseStream: false,
      options: {},
    },
    certParse: {
      name: "CertParse",
      requestType: CertRequest,
      requestStream: false,
      responseType: CertResponse,
      responseStream: false,
      options: {},
    },
    colorConvert: {
      name: "ColorConvert",
      requestType: ColorRequest,
      requestStream: false,
      responseType: ColorResponse,
      responseStream: false,
      options: {},
    },
    caseConvert: {
      name: "CaseConvert",
      requestType: CaseRequest,
      requestStream: false,
      responseType: CaseResponse,
      responseStream: false,
      options: {},
    },
    stringEscape: {
      name: "StringEscape",
      requestType: EscapeRequest,
      requestStream: false,
      responseType: EscapeResponse,
      responseStream: false,
      options: {},
    },
    textSimilarity: {
      name: "TextSimilarity",
      requestType: SimilarityRequest,
      requestStream: false,
      responseType: SimilarityResponse,
      responseStream: false,
      options: {},
    },
    sqlFormat: {
      name: "SqlFormat",
      requestType: SqlRequest,
      requestStream: false,
      responseType: SqlResponse,
      responseStream: false,
      options: {},
    },
    ipCalc: {
      name: "IpCalc",
      requestType: IpRequest,
      requestStream: false,
      responseType: IpResponse,
      responseStream: false,
      options: {},
    },
    generatePassword: {
      name: "GeneratePassword",
      requestType: PasswordRequest,
      requestStream: false,
      responseType: PasswordResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

export interface PrivUtilServiceImplementation<CallContextExt = {}> {
  diff(request: DiffRequest, context: CallContext & CallContextExt): Promise<DeepPartial<DiffResponse>>;
  base64Encode(request: Base64Request, context: CallContext & CallContextExt): Promise<DeepPartial<Base64Response>>;
  base64Decode(request: Base64Request, context: CallContext & CallContextExt): Promise<DeepPartial<Base64Response>>;
  jsonFormat(
    request: JsonFormatRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<JsonFormatResponse>>;
  convert(request: ConvertRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ConvertResponse>>;
  generateUuid(request: UuidRequest, context: CallContext & CallContextExt): Promise<DeepPartial<UuidResponse>>;
  generateLorem(request: LoremRequest, context: CallContext & CallContextExt): Promise<DeepPartial<LoremResponse>>;
  calculateHash(request: HashRequest, context: CallContext & CallContextExt): Promise<DeepPartial<HashResponse>>;
  textInspect(
    request: TextInspectRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TextInspectResponse>>;
  textManipulate(
    request: TextManipulateRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<TextManipulateResponse>>;
  urlEncode(request: TextRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TextResponse>>;
  urlDecode(request: TextRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TextResponse>>;
  htmlEncode(request: TextRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TextResponse>>;
  htmlDecode(request: TextRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TextResponse>>;
  timeConvert(request: TimeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<TimeResponse>>;
  jwtDecode(request: JwtRequest, context: CallContext & CallContextExt): Promise<DeepPartial<JwtResponse>>;
  regexTest(request: RegexRequest, context: CallContext & CallContextExt): Promise<DeepPartial<RegexResponse>>;
  jsonToGo(request: JsonToGoRequest, context: CallContext & CallContextExt): Promise<DeepPartial<JsonToGoResponse>>;
  cronExplain(request: CronRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CronResponse>>;
  certParse(request: CertRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CertResponse>>;
  colorConvert(request: ColorRequest, context: CallContext & CallContextExt): Promise<DeepPartial<ColorResponse>>;
  caseConvert(request: CaseRequest, context: CallContext & CallContextExt): Promise<DeepPartial<CaseResponse>>;
  stringEscape(request: EscapeRequest, context: CallContext & CallContextExt): Promise<DeepPartial<EscapeResponse>>;
  textSimilarity(
    request: SimilarityRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SimilarityResponse>>;
  sqlFormat(request: SqlRequest, context: CallContext & CallContextExt): Promise<DeepPartial<SqlResponse>>;
  ipCalc(request: IpRequest, context: CallContext & CallContextExt): Promise<DeepPartial<IpResponse>>;
  generatePassword(
    request: PasswordRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<PasswordResponse>>;
}

export interface PrivUtilServiceClient<CallOptionsExt = {}> {
  diff(request: DeepPartial<DiffRequest>, options?: CallOptions & CallOptionsExt): Promise<DiffResponse>;
  base64Encode(request: DeepPartial<Base64Request>, options?: CallOptions & CallOptionsExt): Promise<Base64Response>;
  base64Decode(request: DeepPartial<Base64Request>, options?: CallOptions & CallOptionsExt): Promise<Base64Response>;
  jsonFormat(
    request: DeepPartial<JsonFormatRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<JsonFormatResponse>;
  convert(request: DeepPartial<ConvertRequest>, options?: CallOptions & CallOptionsExt): Promise<ConvertResponse>;
  generateUuid(request: DeepPartial<UuidRequest>, options?: CallOptions & CallOptionsExt): Promise<UuidResponse>;
  generateLorem(request: DeepPartial<LoremRequest>, options?: CallOptions & CallOptionsExt): Promise<LoremResponse>;
  calculateHash(request: DeepPartial<HashRequest>, options?: CallOptions & CallOptionsExt): Promise<HashResponse>;
  textInspect(
    request: DeepPartial<TextInspectRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TextInspectResponse>;
  textManipulate(
    request: DeepPartial<TextManipulateRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<TextManipulateResponse>;
  urlEncode(request: DeepPartial<TextRequest>, options?: CallOptions & CallOptionsExt): Promise<TextResponse>;
  urlDecode(request: DeepPartial<TextRequest>, options?: CallOptions & CallOptionsExt): Promise<TextResponse>;
  htmlEncode(request: DeepPartial<TextRequest>, options?: CallOptions & CallOptionsExt): Promise<TextResponse>;
  htmlDecode(request: DeepPartial<TextRequest>, options?: CallOptions & CallOptionsExt): Promise<TextResponse>;
  timeConvert(request: DeepPartial<TimeRequest>, options?: CallOptions & CallOptionsExt): Promise<TimeResponse>;
  jwtDecode(request: DeepPartial<JwtRequest>, options?: CallOptions & CallOptionsExt): Promise<JwtResponse>;
  regexTest(request: DeepPartial<RegexRequest>, options?: CallOptions & CallOptionsExt): Promise<RegexResponse>;
  jsonToGo(request: DeepPartial<JsonToGoRequest>, options?: CallOptions & CallOptionsExt): Promise<JsonToGoResponse>;
  cronExplain(request: DeepPartial<CronRequest>, options?: CallOptions & CallOptionsExt): Promise<CronResponse>;
  certParse(request: DeepPartial<CertRequest>, options?: CallOptions & CallOptionsExt): Promise<CertResponse>;
  colorConvert(request: DeepPartial<ColorRequest>, options?: CallOptions & CallOptionsExt): Promise<ColorResponse>;
  caseConvert(request: DeepPartial<CaseRequest>, options?: CallOptions & CallOptionsExt): Promise<CaseResponse>;
  stringEscape(request: DeepPartial<EscapeRequest>, options?: CallOptions & CallOptionsExt): Promise<EscapeResponse>;
  textSimilarity(
    request: DeepPartial<SimilarityRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SimilarityResponse>;
  sqlFormat(request: DeepPartial<SqlRequest>, options?: CallOptions & CallOptionsExt): Promise<SqlResponse>;
  ipCalc(request: DeepPartial<IpRequest>, options?: CallOptions & CallOptionsExt): Promise<IpResponse>;
  generatePassword(
    request: DeepPartial<PasswordRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<PasswordResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
