package api

import (
	"context"
	"encoding/json"
	"fmt"
	"regexp"
	"sort"
	"strconv"
	"strings"

	"github.com/clbanning/mxj/v2"
	"gopkg.in/yaml.v3"

	pb "github.com/odinnordico/privutil/proto"
)

func (s *Server) JsonFormat(ctx context.Context, req *pb.JsonFormatRequest) (*pb.JsonFormatResponse, error) {
	var data interface{}
	if err := json.Unmarshal([]byte(req.Text), &data); err != nil {
		return &pb.JsonFormatResponse{Error: fmt.Sprintf("Invalid JSON: %v", err)}, nil
	}

	var formatted []byte
	var err error

	if req.Indent == "min" {
		formatted, err = json.Marshal(data)
	} else {
		indent := "  " // default 2 spaces
		if req.Indent == "4" {
			indent = "    "
		} else if req.Indent == "tab" {
			indent = "\t"
		}

		formatted, err = json.MarshalIndent(data, "", indent)
	}

	if err != nil {
		return &pb.JsonFormatResponse{Error: fmt.Sprintf("Formatting failed: %v", err)}, nil
	}

	return &pb.JsonFormatResponse{Text: string(formatted)}, nil
}

func (s *Server) Convert(ctx context.Context, req *pb.ConvertRequest) (*pb.ConvertResponse, error) {
	var data interface{}
	var err error

	switch req.SourceFormat {
	case pb.DataFormat_JSON:
		err = json.Unmarshal([]byte(req.Data), &data)
	case pb.DataFormat_YAML:
		err = yaml.Unmarshal([]byte(req.Data), &data)
	case pb.DataFormat_XML:
		mv, merr := mxj.NewMapXml([]byte(req.Data))
		if merr != nil {
			err = merr
		} else {
			data = mv
		}
	}

	if err != nil {
		return &pb.ConvertResponse{Error: fmt.Sprintf("Parse failed: %v", err)}, nil
	}

	var output []byte
	switch req.TargetFormat {
	case pb.DataFormat_JSON:
		output, err = json.MarshalIndent(data, "", "  ")
	case pb.DataFormat_YAML:
		output, err = yaml.Marshal(data)
	case pb.DataFormat_XML:
		m, ok := data.(map[string]interface{})
		if !ok {
			b, _ := json.Marshal(data)
			mv, _ := mxj.NewMapJson(b)
			output, err = mv.XmlIndent("", "  ")
		} else {
			mv := mxj.Map(m)
			output, err = mv.XmlIndent("", "  ")
		}
	}

	if err != nil {
		return &pb.ConvertResponse{Error: fmt.Sprintf("Conversion failed: %v", err)}, nil
	}

	return &pb.ConvertResponse{Data: string(output)}, nil
}

func (s *Server) JsonToGo(ctx context.Context, req *pb.JsonToGoRequest) (*pb.JsonToGoResponse, error) {
	var data interface{}
	if err := json.Unmarshal([]byte(req.Json), &data); err != nil {
		return &pb.JsonToGoResponse{Error: fmt.Sprintf("Invalid JSON: %v", err)}, nil
	}

	name := req.StructName
	if name == "" {
		name = "AutoGenerated"
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("type %s struct {\n", name))

	m, ok := data.(map[string]interface{})
	if ok {
		var keys []string
		for k := range m {
			keys = append(keys, k)
		}
		sort.Strings(keys)

		for _, k := range keys {
			val := m[k]
			fieldName := toPascalCase(k)
			typeName := "interface{}"

			switch v := val.(type) {
			case string:
				typeName = "string"
			case float64:
				typeName = "float64"
				if v == float64(int64(v)) {
					typeName = "int"
				}
			case bool:
				typeName = "bool"
			case []interface{}:
				typeName = "[]interface{}"
			case map[string]interface{}:
				typeName = "struct { ... }"
			}

			sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, typeName, k))
		}
	} else {
		sb.WriteString("\t// Root must be an object\n")
	}

	sb.WriteString("}")
	return &pb.JsonToGoResponse{GoCode: sb.String()}, nil
}

func (s *Server) SqlFormat(ctx context.Context, req *pb.SqlRequest) (*pb.SqlResponse, error) {
	sql := req.Query
	keywords := []string{"select", "from", "where", "insert", "update", "delete", "create", "drop", "alter", "table", "into", "values", "join", "on", "order by", "group by", "limit", "offset", "and", "or", "not", "null", "as"}

	formatted := sql
	for _, kw := range keywords {
		re := regexp.MustCompile(`(?i)\b` + regexp.QuoteMeta(kw) + `\b`)
		formatted = re.ReplaceAllStringFunc(formatted, strings.ToUpper)
	}

	major := []string{"SELECT", "FROM", "WHERE", "INSERT", "UPDATE", "DELETE", "ORDER BY", "GROUP BY", "LIMIT"}
	for _, kw := range major {
		if strings.Contains(formatted, kw) {
			formatted = strings.ReplaceAll(formatted, kw, "\n"+kw)
		}
	}
	formatted = strings.TrimSpace(formatted)

	return &pb.SqlResponse{Formatted: formatted}, nil
}

func (s *Server) ColorConvert(ctx context.Context, req *pb.ColorRequest) (*pb.ColorResponse, error) {
	input := strings.TrimSpace(req.Input)
	var r, g, b uint8
	var err error

	if strings.HasPrefix(input, "#") {
		input = strings.TrimPrefix(input, "#")
		if len(input) == 3 {
			input = string([]byte{input[0], input[0], input[1], input[1], input[2], input[2]})
		}
		if len(input) == 6 {
			if v, e := strconv.ParseUint(input, 16, 32); e == nil {
				r = uint8(v >> 16) // #nosec G115
				g = uint8(v >> 8)  // #nosec G115
				b = uint8(v)       // #nosec G115
			} else {
				err = e
			}
		} else {
			err = fmt.Errorf("invalid hex length")
		}
	} else if strings.HasPrefix(input, "rgb") {
		re := regexp.MustCompile(`rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)`)
		matches := re.FindStringSubmatch(input)
		if len(matches) == 4 {
			ri, _ := strconv.Atoi(matches[1])
			gi, _ := strconv.Atoi(matches[2])
			bi, _ := strconv.Atoi(matches[3])
			r, g, b = uint8(ri), uint8(gi), uint8(bi) // #nosec G115
		} else {
			err = fmt.Errorf("invalid rgb format")
		}
	} else {
		err = fmt.Errorf("unsupported format (use #Hex or rgb(...) )")
	}

	if err != nil {
		return &pb.ColorResponse{Error: err.Error()}, nil
	}

	rf, gf, bf := float64(r)/255.0, float64(g)/255.0, float64(b)/255.0
	maxC := max(rf, max(gf, bf))
	minC := min(rf, min(gf, bf))
	delta := maxC - minC

	var hue, sat, lum float64
	lum = (maxC + minC) / 2

	if delta == 0 {
		hue = 0
		sat = 0
	} else {
		if lum < 0.5 {
			sat = delta / (maxC + minC)
		} else {
			sat = delta / (2 - maxC - minC)
		}

		switch maxC {
		case rf:
			hue = (gf - bf) / delta
			if gf < bf {
				hue += 6
			}
		case gf:
			hue = (bf-rf)/delta + 2
		case bf:
			hue = (rf-gf)/delta + 4
		}
		hue /= 6
	}

	return &pb.ColorResponse{
		Hex: fmt.Sprintf("#%02x%02x%02x", r, g, b),
		Rgb: fmt.Sprintf("rgb(%d, %d, %d)", r, g, b),
		Hsl: fmt.Sprintf("hsl(%.0f, %.0f%%, %.0f%%)", hue*360, sat*100, lum*100),
	}, nil
}

func toPascalCase(s string) string {
	s = strings.ReplaceAll(s, "_", " ")
	s = strings.ReplaceAll(s, "-", " ")
	words := strings.Fields(s)
	for i, w := range words {
		if len(w) > 0 {
			words[i] = strings.ToUpper(w[:1]) + w[1:]
		}
	}
	return strings.Join(words, "")
}

func max(a, b float64) float64 {
	if a > b {
		return a
	}
	return b
}

func min(a, b float64) float64 {
	if a < b {
		return a
	}
	return b
}
