
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/odinnordico/privutil/internal/api/grpc_server.go (77.1%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package api

import (
        "bytes"
        "context"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "crypto/x509"
        "encoding/base64"
        "encoding/hex"
        "encoding/json"
        "encoding/pem"
        "fmt"
        "html"
        "net"
        "net/url"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "time"
        "unicode"

        "github.com/brianvoe/gofakeit/v6"
        "github.com/clbanning/mxj/v2"
        "github.com/google/uuid"
        "github.com/gorhill/cronexpr"
        "github.com/sergi/go-diff/diffmatchpatch"
        "gopkg.in/yaml.v3"

        pb "github.com/odinnordico/privutil/proto"
)

type Server struct {
        pb.UnimplementedPrivUtilServiceServer
}

func NewServer() *Server <span class="cov8" title="1">{
        return &amp;Server{}
}</span>

func (s *Server) Diff(ctx context.Context, req *pb.DiffRequest) (*pb.DiffResponse, error) <span class="cov8" title="1">{
        dmp := diffmatchpatch.New()
        diffs := dmp.DiffMain(req.Text1, req.Text2, false)
        html := dmp.DiffPrettyHtml(diffs)

        return &amp;pb.DiffResponse{
                DiffHtml: fmt.Sprintf("&lt;div class='diff-output'&gt;%s&lt;/div&gt;", html),
        }, nil
}</span>

func (s *Server) Base64Encode(ctx context.Context, req *pb.Base64Request) (*pb.Base64Response, error) <span class="cov8" title="1">{
        encoded := base64.StdEncoding.EncodeToString([]byte(req.Text))
        return &amp;pb.Base64Response{
                Text: encoded,
        }, nil
}</span>

func (s *Server) Base64Decode(ctx context.Context, req *pb.Base64Request) (*pb.Base64Response, error) <span class="cov8" title="1">{
        decoded, err := base64.StdEncoding.DecodeString(req.Text)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;pb.Base64Response{
                        Error: fmt.Sprintf("Failed to decode: %v", err),
                }, nil
        }</span>
        <span class="cov8" title="1">return &amp;pb.Base64Response{
                Text: string(decoded),
        }, nil</span>
}

func (s *Server) JsonFormat(ctx context.Context, req *pb.JsonFormatRequest) (*pb.JsonFormatResponse, error) <span class="cov8" title="1">{
        var data interface{}
        if err := json.Unmarshal([]byte(req.Text), &amp;data); err != nil </span><span class="cov8" title="1">{
                return &amp;pb.JsonFormatResponse{Error: fmt.Sprintf("Invalid JSON: %v", err)}, nil
        }</span>

        <span class="cov8" title="1">var formatted []byte
        var err error

        if req.Indent == "min" </span><span class="cov8" title="1">{
                formatted, err = json.Marshal(data)
        }</span> else<span class="cov8" title="1"> {
                indent := "  " // default 2 spaces
                if req.Indent == "4" </span><span class="cov0" title="0">{
                        indent = "    "
                }</span> else<span class="cov8" title="1"> if req.Indent == "tab" </span><span class="cov8" title="1">{
                        indent = "\t"
                }</span>

                <span class="cov8" title="1">formatted, err = json.MarshalIndent(data, "", indent)</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return &amp;pb.JsonFormatResponse{Error: fmt.Sprintf("Formatting failed: %v", err)}, nil
        }</span>

        <span class="cov8" title="1">return &amp;pb.JsonFormatResponse{Text: string(formatted)}, nil</span>
}

func (s *Server) Convert(ctx context.Context, req *pb.ConvertRequest) (*pb.ConvertResponse, error) <span class="cov8" title="1">{
        var data interface{}
        var err error

        switch req.SourceFormat </span>{
        case pb.DataFormat_JSON:<span class="cov8" title="1">
                err = json.Unmarshal([]byte(req.Data), &amp;data)</span>
        case pb.DataFormat_YAML:<span class="cov8" title="1">
                err = yaml.Unmarshal([]byte(req.Data), &amp;data)</span>
        case pb.DataFormat_XML:<span class="cov0" title="0">
                mv, merr := mxj.NewMapXml([]byte(req.Data))
                if merr != nil </span><span class="cov0" title="0">{
                        err = merr
                }</span> else<span class="cov0" title="0"> {
                        data = mv
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return &amp;pb.ConvertResponse{Error: fmt.Sprintf("Parse failed: %v", err)}, nil
        }</span>

        <span class="cov8" title="1">var output []byte
        switch req.TargetFormat </span>{
        case pb.DataFormat_JSON:<span class="cov8" title="1">
                output, err = json.MarshalIndent(data, "", "  ")</span>
        case pb.DataFormat_YAML:<span class="cov8" title="1">
                output, err = yaml.Marshal(data)</span>
        case pb.DataFormat_XML:<span class="cov8" title="1">
                m, ok := data.(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        b, _ := json.Marshal(data)
                        mv, _ := mxj.NewMapJson(b)
                        output, err = mv.XmlIndent("", "  ")
                }</span> else<span class="cov8" title="1"> {
                        mv := mxj.Map(m)
                        output, err = mv.XmlIndent("", "  ")
                }</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return &amp;pb.ConvertResponse{Error: fmt.Sprintf("Conversion failed: %v", err)}, nil
        }</span>

        <span class="cov8" title="1">return &amp;pb.ConvertResponse{Data: string(output)}, nil</span>
}

func (s *Server) GenerateUuid(ctx context.Context, req *pb.UuidRequest) (*pb.UuidResponse, error) <span class="cov8" title="1">{
        var uuids []string
        count := req.Count
        if count &lt;= 0 </span><span class="cov0" title="0">{
                count = 1
        }</span>
        <span class="cov8" title="1">if count &gt; 100 </span><span class="cov0" title="0">{
                count = 100
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; int(count); i++ </span><span class="cov8" title="1">{
                var u uuid.UUID
                var err error

                if req.Version == "v1" </span><span class="cov8" title="1">{
                        u, err = uuid.NewUUID()
                }</span> else<span class="cov8" title="1"> {
                        u, err = uuid.NewRandom()
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">str := u.String()
                if !req.Hyphen </span><span class="cov8" title="1">{
                        str = strings.ReplaceAll(str, "-", "")
                }</span>
                <span class="cov8" title="1">if req.Uppercase </span><span class="cov8" title="1">{
                        str = strings.ToUpper(str)
                }</span>
                <span class="cov8" title="1">uuids = append(uuids, str)</span>
        }

        <span class="cov8" title="1">return &amp;pb.UuidResponse{Uuids: uuids}, nil</span>
}

func (s *Server) GenerateLorem(ctx context.Context, req *pb.LoremRequest) (*pb.LoremResponse, error) <span class="cov8" title="1">{
        var text string
        count := int(req.Count)
        if count &lt;= 0 </span><span class="cov0" title="0">{
                count = 1
        }</span>

        <span class="cov8" title="1">switch req.Type </span>{
        case "word":<span class="cov8" title="1">
                var words []string
                for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                        words = append(words, gofakeit.Word())
                }</span>
                <span class="cov8" title="1">text = strings.Join(words, " ")</span>
        case "sentence":<span class="cov8" title="1">
                var sentences []string
                for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                        sentences = append(sentences, gofakeit.Sentence(10))
                }</span>
                <span class="cov8" title="1">text = strings.Join(sentences, " ")</span>
        default:<span class="cov8" title="1">
                var paragraphs []string
                for i := 0; i &lt; count; i++ </span><span class="cov8" title="1">{
                        paragraphs = append(paragraphs, gofakeit.Paragraph(3, 5, 10, "\n"))
                }</span>
                <span class="cov8" title="1">text = strings.Join(paragraphs, "\n\n")</span>
        }

        <span class="cov8" title="1">return &amp;pb.LoremResponse{Text: text}, nil</span>
}

func (s *Server) CalculateHash(ctx context.Context, req *pb.HashRequest) (*pb.HashResponse, error) <span class="cov8" title="1">{
        var hash string
        data := []byte(req.Text)

        switch req.Algo </span>{
        case "md5":<span class="cov8" title="1">
                sum := md5.Sum(data)
                hash = hex.EncodeToString(sum[:])</span>
        case "sha1":<span class="cov8" title="1">
                sum := sha1.Sum(data)
                hash = hex.EncodeToString(sum[:])</span>
        case "sha512":<span class="cov8" title="1">
                sum := sha512.Sum512(data)
                hash = hex.EncodeToString(sum[:])</span>
        default:<span class="cov8" title="1">
                sum := sha256.Sum256(data)
                hash = hex.EncodeToString(sum[:])</span>
        }

        <span class="cov8" title="1">return &amp;pb.HashResponse{Hash: hash}, nil</span>
}

func (s *Server) TextInspect(ctx context.Context, req *pb.TextInspectRequest) (*pb.TextInspectResponse, error) <span class="cov8" title="1">{
        text := req.Text
        return &amp;pb.TextInspectResponse{
                CharCount: int32(len([]rune(text))),
                WordCount: int32(len(strings.Fields(text))),
                LineCount: int32(len(strings.Split(text, "\n"))),
                ByteCount: int32(len(text)),
        }, nil
}</span>

func (s *Server) TextManipulate(ctx context.Context, req *pb.TextManipulateRequest) (*pb.TextManipulateResponse, error) <span class="cov8" title="1">{
        text := req.Text
        lines := strings.Split(text, "\n")
        var result string

        switch req.Action </span>{
        case pb.TextAction_SORT_AZ:<span class="cov8" title="1">
                sort.Strings(lines)
                result = strings.Join(lines, "\n")</span>
        case pb.TextAction_SORT_ZA:<span class="cov8" title="1">
                sort.Sort(sort.Reverse(sort.StringSlice(lines)))
                result = strings.Join(lines, "\n")</span>
        case pb.TextAction_REVERSE:<span class="cov8" title="1">
                for i, j := 0, len(lines)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                        lines[i], lines[j] = lines[j], lines[i]
                }</span>
                <span class="cov8" title="1">result = strings.Join(lines, "\n")</span>
        case pb.TextAction_DEDUPE:<span class="cov8" title="1">
                seen := make(map[string]bool)
                var unique []string
                for _, line := range lines </span><span class="cov8" title="1">{
                        if !seen[line] </span><span class="cov8" title="1">{
                                seen[line] = true
                                unique = append(unique, line)
                        }</span>
                }
                <span class="cov8" title="1">result = strings.Join(unique, "\n")</span>
        case pb.TextAction_REMOVE_EMPTY:<span class="cov8" title="1">
                var nonEmpty []string
                for _, line := range lines </span><span class="cov8" title="1">{
                        if strings.TrimSpace(line) != "" </span><span class="cov8" title="1">{
                                nonEmpty = append(nonEmpty, line)
                        }</span>
                }
                <span class="cov8" title="1">result = strings.Join(nonEmpty, "\n")</span>
        case pb.TextAction_TRIM:<span class="cov8" title="1">
                var trimmed []string
                for _, line := range lines </span><span class="cov8" title="1">{
                        trimmed = append(trimmed, strings.TrimSpace(line))
                }</span>
                <span class="cov8" title="1">result = strings.Join(trimmed, "\n")</span>
        default:<span class="cov0" title="0">
                result = text</span>
        }

        <span class="cov8" title="1">return &amp;pb.TextManipulateResponse{Text: result}, nil</span>
}

func (s *Server) UrlEncode(ctx context.Context, req *pb.TextRequest) (*pb.TextResponse, error) <span class="cov8" title="1">{
        return &amp;pb.TextResponse{Text: url.QueryEscape(req.Text)}, nil
}</span>

func (s *Server) UrlDecode(ctx context.Context, req *pb.TextRequest) (*pb.TextResponse, error) <span class="cov8" title="1">{
        decoded, err := url.QueryUnescape(req.Text)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;pb.TextResponse{Text: "Error: " + err.Error()}, nil
        }</span>
        <span class="cov8" title="1">return &amp;pb.TextResponse{Text: decoded}, nil</span>
}

func (s *Server) HtmlEncode(ctx context.Context, req *pb.TextRequest) (*pb.TextResponse, error) <span class="cov8" title="1">{
        return &amp;pb.TextResponse{Text: html.EscapeString(req.Text)}, nil
}</span>

func (s *Server) HtmlDecode(ctx context.Context, req *pb.TextRequest) (*pb.TextResponse, error) <span class="cov8" title="1">{
        return &amp;pb.TextResponse{Text: html.UnescapeString(req.Text)}, nil
}</span>

func (s *Server) TimeConvert(ctx context.Context, req *pb.TimeRequest) (*pb.TimeResponse, error) <span class="cov8" title="1">{
        input := strings.TrimSpace(req.Input)
        var t time.Time

        if input == "" || strings.EqualFold(input, "now") </span><span class="cov8" title="1">{
                t = time.Now()
        }</span> else<span class="cov8" title="1"> {
                if ts, err := strconv.ParseInt(input, 10, 64); err == nil </span><span class="cov8" title="1">{
                        if ts &gt; 10000000000 </span><span class="cov8" title="1">{
                                t = time.UnixMilli(ts)
                        }</span> else<span class="cov8" title="1"> {
                                t = time.Unix(ts, 0)
                        }</span>
                } else<span class="cov8" title="1"> {
                        formats := []string{
                                time.RFC3339,
                                time.RFC3339Nano,
                                time.Layout,
                                "2006-01-02T15:04:05",
                                "2006-01-02 15:04:05",
                                time.RubyDate,
                                time.UnixDate,
                        }
                        var parsed bool
                        for _, layout := range formats </span><span class="cov8" title="1">{
                                if pt, err := time.Parse(layout, input); err == nil </span><span class="cov8" title="1">{
                                        t = pt
                                        parsed = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !parsed </span><span class="cov0" title="0">{
                                return &amp;pb.TimeResponse{Iso: "Invalid input format"}, nil
                        }</span>
                }
        }

        <span class="cov8" title="1">return &amp;pb.TimeResponse{
                Unix:  t.Unix(),
                Utc:   t.UTC().Format(time.RFC3339),
                Local: t.Local().Format("2006-01-02 15:04:05 -0700 MST"),
                Iso:   t.Format(time.RFC3339),
        }, nil</span>
}

func (s *Server) JwtDecode(ctx context.Context, req *pb.JwtRequest) (*pb.JwtResponse, error) <span class="cov8" title="1">{
        parts := strings.Split(req.Token, ".")
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return &amp;pb.JwtResponse{Error: "Invalid JWT format"}, nil
        }</span>

        <span class="cov8" title="1">decodeSegment := func(seg string) string </span><span class="cov8" title="1">{
                if l := len(seg) % 4; l &gt; 0 </span><span class="cov8" title="1">{
                        seg += strings.Repeat("=", 4-l)
                }</span>
                <span class="cov8" title="1">b, err := base64.URLEncoding.DecodeString(seg)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Error decoding: %v", err)
                }</span>
                <span class="cov8" title="1">var pretty bytes.Buffer
                if err := json.Indent(&amp;pretty, b, "", "  "); err == nil </span><span class="cov8" title="1">{
                        return pretty.String()
                }</span>
                <span class="cov0" title="0">return string(b)</span>
        }

        <span class="cov8" title="1">return &amp;pb.JwtResponse{
                Header:  decodeSegment(parts[0]),
                Payload: decodeSegment(parts[1]),
        }, nil</span>
}

func (s *Server) RegexTest(ctx context.Context, req *pb.RegexRequest) (*pb.RegexResponse, error) <span class="cov8" title="1">{
        re, err := regexp.Compile(req.Pattern)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;pb.RegexResponse{Error: fmt.Sprintf("Invalid Pattern: %v", err)}, nil
        }</span>

        <span class="cov8" title="1">matches := re.FindAllString(req.Text, -1)
        return &amp;pb.RegexResponse{
                Match:   len(matches) &gt; 0,
                Matches: matches,
        }, nil</span>
}

func (s *Server) JsonToGo(ctx context.Context, req *pb.JsonToGoRequest) (*pb.JsonToGoResponse, error) <span class="cov8" title="1">{
        var data interface{}
        if err := json.Unmarshal([]byte(req.Json), &amp;data); err != nil </span><span class="cov0" title="0">{
                return &amp;pb.JsonToGoResponse{Error: fmt.Sprintf("Invalid JSON: %v", err)}, nil
        }</span>

        <span class="cov8" title="1">name := req.StructName
        if name == "" </span><span class="cov0" title="0">{
                name = "AutoGenerated"
        }</span>

        <span class="cov8" title="1">var sb strings.Builder
        sb.WriteString(fmt.Sprintf("type %s struct {\n", name))

        m, ok := data.(map[string]interface{})
        if ok </span><span class="cov8" title="1">{
                var keys []string
                for k := range m </span><span class="cov8" title="1">{
                        keys = append(keys, k)
                }</span>
                <span class="cov8" title="1">sort.Strings(keys)

                for _, k := range keys </span><span class="cov8" title="1">{
                        v := m[k]
                        fieldName := toPascalCase(k)
                        typeName := "interface{}"

                        switch v.(type) </span>{
                        case string:<span class="cov8" title="1">
                                typeName = "string"</span>
                        case float64:<span class="cov8" title="1">
                                typeName = "float64"
                                if f, ok := v.(float64); ok &amp;&amp; f == float64(int64(f)) </span><span class="cov8" title="1">{
                                        typeName = "int"
                                }</span>
                        case bool:<span class="cov8" title="1">
                                typeName = "bool"</span>
                        case []interface{}:<span class="cov0" title="0">
                                typeName = "[]interface{}"</span>
                        case map[string]interface{}:<span class="cov0" title="0">
                                typeName = "struct { ... }"</span>
                        }

                        <span class="cov8" title="1">sb.WriteString(fmt.Sprintf("\t%s %s `json:\"%s\"`\n", fieldName, typeName, k))</span>
                }
        } else<span class="cov0" title="0"> {
                sb.WriteString("\t// Root must be an object\n")
        }</span>

        <span class="cov8" title="1">sb.WriteString("}")
        return &amp;pb.JsonToGoResponse{GoCode: sb.String()}, nil</span>
}

func (s *Server) CronExplain(ctx context.Context, req *pb.CronRequest) (*pb.CronResponse, error) <span class="cov8" title="1">{
        expr, err := cronexpr.Parse(req.Expression)
        if err != nil </span><span class="cov8" title="1">{
                return &amp;pb.CronResponse{Error: fmt.Sprintf("Invalid cron expression: %v", err)}, nil
        }</span>

        <span class="cov8" title="1">nextTimes := expr.NextN(time.Now(), 5)
        var nextRuns []string
        for _, t := range nextTimes </span><span class="cov8" title="1">{
                nextRuns = append(nextRuns, t.Format(time.RFC3339))
        }</span>

        <span class="cov8" title="1">desc := describeCron(req.Expression)

        return &amp;pb.CronResponse{
                Description: desc,
                NextRuns:    strings.Join(nextRuns, "\n"),
        }, nil</span>
}

func describeCron(expr string) string <span class="cov8" title="1">{
        parts := strings.Fields(expr)
        if len(parts) != 5 </span><span class="cov0" title="0">{
                return "Invalid cron expression format"
        }</span>
        <span class="cov8" title="1">min, hour, dom, month, dow := parts[0], parts[1], parts[2], parts[3], parts[4]

        // Very basic heuristic description
        if expr == "* * * * *" </span><span class="cov8" title="1">{
                return "Every minute"
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(min, "*/") &amp;&amp; hour == "*" &amp;&amp; dom == "*" &amp;&amp; month == "*" &amp;&amp; dow == "*" </span><span class="cov8" title="1">{
                return fmt.Sprintf("Every %s minutes", min[2:])
        }</span>
        <span class="cov0" title="0">if min == "0" &amp;&amp; hour == "*" &amp;&amp; dom == "*" &amp;&amp; month == "*" &amp;&amp; dow == "*" </span><span class="cov0" title="0">{
                return "At the start of every hour"
        }</span>
        <span class="cov0" title="0">if min == "0" &amp;&amp; strings.HasPrefix(hour, "*/") &amp;&amp; dom == "*" &amp;&amp; month == "*" &amp;&amp; dow == "*" </span><span class="cov0" title="0">{
                return fmt.Sprintf("At minute 0 past every %s hours", hour[2:])
        }</span>
        <span class="cov0" title="0">if min == "0" &amp;&amp; hour == "0" &amp;&amp; dom == "*" &amp;&amp; month == "*" &amp;&amp; dow == "*" </span><span class="cov0" title="0">{
                return "At 00:00 every day"
        }</span>

        // Complex cases fallback
        <span class="cov0" title="0">desc := "Run "
        if min != "*" </span><span class="cov0" title="0">{
                desc += fmt.Sprintf("at minute %s", min)
        }</span> else<span class="cov0" title="0"> {
                desc += "every minute"
        }</span>

        <span class="cov0" title="0">if hour != "*" </span><span class="cov0" title="0">{
                desc += fmt.Sprintf(" of hour %s", hour)
        }</span>

        <span class="cov0" title="0">if dom != "*" </span><span class="cov0" title="0">{
                desc += fmt.Sprintf(" on day-of-month %s", dom)
        }</span>

        <span class="cov0" title="0">if dow != "*" </span><span class="cov0" title="0">{
                desc += fmt.Sprintf(" on day-of-week %s", dow)
        }</span>

        <span class="cov0" title="0">return desc</span>
}

func (s *Server) CertParse(ctx context.Context, req *pb.CertRequest) (*pb.CertResponse, error) <span class="cov8" title="1">{
        block, _ := pem.Decode([]byte(req.Data))
        if block == nil </span><span class="cov8" title="1">{
                return &amp;pb.CertResponse{Error: "Failed to decode PEM block"}, nil
        }</span>

        <span class="cov0" title="0">cert, err := x509.ParseCertificate(block.Bytes)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;pb.CertResponse{Error: fmt.Sprintf("Failed to parse certificate: %v", err)}, nil
        }</span>

        <span class="cov0" title="0">return &amp;pb.CertResponse{
                Subject:   cert.Subject.String(),
                Issuer:    cert.Issuer.String(),
                NotBefore: cert.NotBefore.Format(time.RFC3339),
                NotAfter:  cert.NotAfter.Format(time.RFC3339),
                Sans:      cert.DNSNames,
        }, nil</span>
}

func (s *Server) ColorConvert(ctx context.Context, req *pb.ColorRequest) (*pb.ColorResponse, error) <span class="cov8" title="1">{
        input := strings.TrimSpace(req.Input)
        var r, g, b uint8
        var err error

        if strings.HasPrefix(input, "#") </span><span class="cov8" title="1">{
                input = strings.TrimPrefix(input, "#")
                if len(input) == 3 </span><span class="cov8" title="1">{
                        input = string([]byte{input[0], input[0], input[1], input[1], input[2], input[2]})
                }</span>
                <span class="cov8" title="1">if len(input) == 6 </span><span class="cov8" title="1">{
                        if v, e := strconv.ParseUint(input, 16, 32); e == nil </span><span class="cov8" title="1">{
                                r = uint8(v &gt;&gt; 16)
                                g = uint8(v &gt;&gt; 8)
                                b = uint8(v)
                        }</span> else<span class="cov0" title="0"> {
                                err = e
                        }</span>
                } else<span class="cov0" title="0"> {
                        err = fmt.Errorf("invalid hex length")
                }</span>
        } else<span class="cov8" title="1"> if strings.HasPrefix(input, "rgb") </span><span class="cov8" title="1">{
                re := regexp.MustCompile(`rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)`)
                matches := re.FindStringSubmatch(input)
                if len(matches) == 4 </span><span class="cov8" title="1">{
                        ri, _ := strconv.Atoi(matches[1])
                        gi, _ := strconv.Atoi(matches[2])
                        bi, _ := strconv.Atoi(matches[3])
                        r, g, b = uint8(ri), uint8(gi), uint8(bi)
                }</span> else<span class="cov0" title="0"> {
                        err = fmt.Errorf("invalid rgb format")
                }</span>
        } else<span class="cov8" title="1"> {
                err = fmt.Errorf("unsupported format (use #Hex or rgb(...) )")
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return &amp;pb.ColorResponse{Error: err.Error()}, nil
        }</span>

        <span class="cov8" title="1">rf, gf, bf := float64(r)/255.0, float64(g)/255.0, float64(b)/255.0
        maxC := max(rf, max(gf, bf))
        minC := min(rf, min(gf, bf))
        delta := maxC - minC

        var hue, sat, lum float64
        lum = (maxC + minC) / 2

        if delta == 0 </span><span class="cov0" title="0">{
                hue = 0
                sat = 0
        }</span> else<span class="cov8" title="1"> {
                if lum &lt; 0.5 </span><span class="cov0" title="0">{
                        sat = delta / (maxC + minC)
                }</span> else<span class="cov8" title="1"> {
                        sat = delta / (2 - maxC - minC)
                }</span>

                <span class="cov8" title="1">switch maxC </span>{
                case rf:<span class="cov8" title="1">
                        hue = (gf - bf) / delta
                        if gf &lt; bf </span><span class="cov0" title="0">{
                                hue += 6
                        }</span>
                case gf:<span class="cov0" title="0">
                        hue = (bf-rf)/delta + 2</span>
                case bf:<span class="cov0" title="0">
                        hue = (rf-gf)/delta + 4</span>
                }
                <span class="cov8" title="1">hue /= 6</span>
        }

        <span class="cov8" title="1">return &amp;pb.ColorResponse{
                Hex: fmt.Sprintf("#%02x%02x%02x", r, g, b),
                Rgb: fmt.Sprintf("rgb(%d, %d, %d)", r, g, b),
                Hsl: fmt.Sprintf("hsl(%.0f, %.0f%%, %.0f%%)", hue*360, sat*100, lum*100),
        }, nil</span>
}

func (s *Server) CaseConvert(ctx context.Context, req *pb.CaseRequest) (*pb.CaseResponse, error) <span class="cov8" title="1">{
        text := req.Text
        words := splitIntoWords(text)

        toCamel := func(words []string) string </span><span class="cov8" title="1">{
                if len(words) == 0 </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov8" title="1">res := strings.ToLower(words[0])
                for _, w := range words[1:] </span><span class="cov8" title="1">{
                        if len(w) &gt; 0 </span><span class="cov8" title="1">{
                                res += strings.ToUpper(w[:1]) + strings.ToLower(w[1:])
                        }</span>
                }
                <span class="cov8" title="1">return res</span>
        }

        <span class="cov8" title="1">toPascal := func(words []string) string </span><span class="cov8" title="1">{
                var res string
                for _, w := range words </span><span class="cov8" title="1">{
                        if len(w) &gt; 0 </span><span class="cov8" title="1">{
                                res += strings.ToUpper(w[:1]) + strings.ToLower(w[1:])
                        }</span>
                }
                <span class="cov8" title="1">return res</span>
        }

        <span class="cov8" title="1">toSnake := func(words []string) string </span><span class="cov8" title="1">{
                var lower []string
                for _, w := range words </span><span class="cov8" title="1">{
                        lower = append(lower, strings.ToLower(w))
                }</span>
                <span class="cov8" title="1">return strings.Join(lower, "_")</span>
        }

        <span class="cov8" title="1">toKebab := func(words []string) string </span><span class="cov8" title="1">{
                var lower []string
                for _, w := range words </span><span class="cov8" title="1">{
                        lower = append(lower, strings.ToLower(w))
                }</span>
                <span class="cov8" title="1">return strings.Join(lower, "-")</span>
        }

        <span class="cov8" title="1">toConstant := func(words []string) string </span><span class="cov8" title="1">{
                var upper []string
                for _, w := range words </span><span class="cov8" title="1">{
                        upper = append(upper, strings.ToUpper(w))
                }</span>
                <span class="cov8" title="1">return strings.Join(upper, "_")</span>
        }

        <span class="cov8" title="1">return &amp;pb.CaseResponse{
                Camel:    toCamel(words),
                Pascal:   toPascal(words),
                Snake:    toSnake(words),
                Kebab:    toKebab(words),
                Constant: toConstant(words),
                Title:    strings.Join(words, " "),
        }, nil</span>
}

func (s *Server) StringEscape(ctx context.Context, req *pb.EscapeRequest) (*pb.EscapeResponse, error) <span class="cov8" title="1">{
        text := req.Text
        var res string
        var err error

        switch req.Mode </span>{
        case "json":<span class="cov8" title="1">
                if req.Action == "escape" </span><span class="cov8" title="1">{
                        b, _ := json.Marshal(text)
                        res = string(b)
                }</span> else<span class="cov8" title="1"> {
                        if strings.HasPrefix(text, "\"") &amp;&amp; strings.HasSuffix(text, "\"") </span><span class="cov8" title="1">{
                                if err := json.Unmarshal([]byte(text), &amp;res); err != nil </span><span class="cov0" title="0">{
                                        return &amp;pb.EscapeResponse{Error: "Invalid JSON string"}, nil
                                }</span>
                        } else<span class="cov0" title="0"> {
                                if err := json.Unmarshal([]byte("\""+text+"\""), &amp;res); err != nil </span><span class="cov0" title="0">{
                                        return &amp;pb.EscapeResponse{Error: "Could not unescape"}, nil
                                }</span>
                        }
                }
        case "html_entity":<span class="cov8" title="1">
                if req.Action == "escape" </span><span class="cov8" title="1">{
                        res = html.EscapeString(text)
                }</span> else<span class="cov0" title="0"> {
                        res = html.UnescapeString(text)
                }</span>
        case "url":<span class="cov8" title="1">
                if req.Action == "escape" </span><span class="cov8" title="1">{
                        res = url.QueryEscape(text)
                }</span> else<span class="cov0" title="0"> {
                        res, err = url.QueryUnescape(text)
                }</span>
        case "sql":<span class="cov0" title="0">
                if req.Action == "escape" </span><span class="cov0" title="0">{
                        res = strings.ReplaceAll(text, "'", "''")
                }</span> else<span class="cov0" title="0"> {
                        res = strings.ReplaceAll(text, "''", "'")
                }</span>
        case "java":<span class="cov0" title="0">
                if req.Action == "escape" </span><span class="cov0" title="0">{
                        res = strconv.Quote(text)
                }</span> else<span class="cov0" title="0"> {
                        res, err = strconv.Unquote(text)
                }</span>
        default:<span class="cov0" title="0">
                return &amp;pb.EscapeResponse{Error: "Unknown mode"}, nil</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return &amp;pb.EscapeResponse{Error: err.Error()}, nil
        }</span>

        <span class="cov8" title="1">return &amp;pb.EscapeResponse{Result: res}, nil</span>
}

func splitIntoWords(s string) []string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, "-", " ")
        s = strings.ReplaceAll(s, "_", " ")
        s = strings.ReplaceAll(s, ".", " ")

        var sb strings.Builder
        runes := []rune(s)
        for i, r := range runes </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; i &lt; len(runes)-1 </span><span class="cov8" title="1">{
                        prev := runes[i-1]
                        next := runes[i+1]
                        if unicode.IsLower(prev) &amp;&amp; unicode.IsUpper(r) </span><span class="cov0" title="0">{
                                sb.WriteRune(' ')
                        }</span>
                        <span class="cov8" title="1">if unicode.IsUpper(prev) &amp;&amp; unicode.IsUpper(r) &amp;&amp; unicode.IsLower(next) </span><span class="cov0" title="0">{
                                sb.WriteRune(' ')
                        }</span>
                }
                <span class="cov8" title="1">sb.WriteRune(r)</span>
        }
        <span class="cov8" title="1">s = sb.String()

        return strings.Fields(s)</span>
}

func toPascalCase(s string) string <span class="cov8" title="1">{
        s = strings.ReplaceAll(s, "_", " ")
        s = strings.ReplaceAll(s, "-", " ")
        words := strings.Fields(s)
        for i, w := range words </span><span class="cov8" title="1">{
                if len(w) &gt; 0 </span><span class="cov8" title="1">{
                        words[i] = strings.ToUpper(w[:1]) + w[1:]
                }</span>
        }
        <span class="cov8" title="1">return strings.Join(words, "")</span>
}

func max(a, b float64) float64 <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func min(a, b float64) float64 <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (s *Server) TextSimilarity(ctx context.Context, req *pb.SimilarityRequest) (*pb.SimilarityResponse, error) <span class="cov8" title="1">{
        // Simple Levenshtein implementation
        s1, s2 := req.Text1, req.Text2
        r1, r2 := []rune(s1), []rune(s2)
        n, m := len(r1), len(r2)
        if n &gt; m </span><span class="cov0" title="0">{
                r1, r2 = r2, r1
                n, m = m, n
        }</span>

        <span class="cov8" title="1">currentRow := make([]int, n+1)
        for i := 0; i &lt;= n; i++ </span><span class="cov8" title="1">{
                currentRow[i] = i
        }</span>

        <span class="cov8" title="1">for i := 1; i &lt;= m; i++ </span><span class="cov8" title="1">{
                previousRow := currentRow
                currentRow = make([]int, n+1)
                currentRow[0] = i
                for j := 1; j &lt;= n; j++ </span><span class="cov8" title="1">{
                        add, del, change := previousRow[j]+1, currentRow[j-1]+1, previousRow[j-1]
                        if r1[j-1] != r2[i-1] </span><span class="cov8" title="1">{
                                change++
                        }</span>
                        <span class="cov8" title="1">currentRow[j] = minInt(add, minInt(del, change))</span>
                }
        }
        <span class="cov8" title="1">dist := currentRow[n]

        // Calculate similarity 0.0 - 1.0
        maxLen := maxInt(n, m)
        var sim float32
        if maxLen == 0 </span><span class="cov0" title="0">{
                sim = 1.0
        }</span> else<span class="cov8" title="1"> {
                sim = 1.0 - float32(dist)/float32(maxLen)
        }</span>

        <span class="cov8" title="1">return &amp;pb.SimilarityResponse{
                Distance:   int32(dist),
                Similarity: sim,
        }, nil</span>
}

func (s *Server) SqlFormat(ctx context.Context, req *pb.SqlRequest) (*pb.SqlResponse, error) <span class="cov8" title="1">{
        // Very basic custom storage formatter
        sql := req.Query
        // Keywords to uppercase
        keywords := []string{"select", "from", "where", "insert", "update", "delete", "create", "drop", "alter", "table", "into", "values", "join", "on", "order by", "group by", "limit", "offset", "and", "or", "not", "null", "as"}

        // Poor man's formatter: uppercase keywords and add format breaks
        // For production usage, a real SQL parsing library is needed.
        // We will settle for regex replacements for common keywords.
        formatted := sql
        for _, kw := range keywords </span><span class="cov8" title="1">{
                re := regexp.MustCompile(`(?i)\b` + regexp.QuoteMeta(kw) + `\b`)
                formatted = re.ReplaceAllStringFunc(formatted, strings.ToUpper)
        }</span>

        // Add newlines before major clauses
        <span class="cov8" title="1">major := []string{"SELECT", "FROM", "WHERE", "INSERT", "UPDATE", "DELETE", "ORDER BY", "GROUP BY", "LIMIT"}
        for _, kw := range major </span><span class="cov8" title="1">{
                if strings.Contains(formatted, kw) </span><span class="cov8" title="1">{
                        formatted = strings.ReplaceAll(formatted, kw, "\n"+kw)
                }</span>
        }
        <span class="cov8" title="1">formatted = strings.TrimSpace(formatted)

        return &amp;pb.SqlResponse{Formatted: formatted}, nil</span>
}

func (s *Server) IpCalc(ctx context.Context, req *pb.IpRequest) (*pb.IpResponse, error) <span class="cov8" title="1">{
        // Using standard library net package
        // Parse CIDR
        ip, ipnet, err := net.ParseCIDR(req.Cidr)
        if err != nil </span><span class="cov8" title="1">{
                // Try parsing as single IP, assume /32 (v4) or /128 (v6) if valid IP
                if ip2 := net.ParseIP(req.Cidr); ip2 != nil </span><span class="cov8" title="1">{
                        if ip2.To4() != nil </span><span class="cov8" title="1">{
                                ip, ipnet, _ = net.ParseCIDR(req.Cidr + "/32")
                        }</span> else<span class="cov0" title="0"> {
                                ip, ipnet, _ = net.ParseCIDR(req.Cidr + "/128")
                        }</span>
                }

                <span class="cov8" title="1">if ip == nil </span><span class="cov8" title="1">{
                        return &amp;pb.IpResponse{Error: "Invalid IP or CIDR"}, nil
                }</span>
        }

        <span class="cov8" title="1">ones, bits := ipnet.Mask.Size()

        // Calculate network, broadcast, first/last IP
        // This is complex for IPv6, implementing simplified version mostly for IPv4

        network := ipnet.IP
        var broadcast net.IP
        var netmask net.IP = net.IP(ipnet.Mask)

        if ip.To4() != nil </span><span class="cov8" title="1">{
                // IPv4 logic
                broadcast = make(net.IP, 4)
                for i := 0; i &lt; 4; i++ </span><span class="cov8" title="1">{
                        broadcast[i] = network[i] | ^ipnet.Mask[i]
                }</span>
        }

        // Count
        <span class="cov8" title="1">var count int64
        if bits-ones &lt; 63 </span><span class="cov8" title="1">{ // Avoid overflow
                count = 1 &lt;&lt; uint(bits-ones)
        }</span>

        <span class="cov8" title="1">return &amp;pb.IpResponse{
                Network:   network.String(),
                Broadcast: broadcast.String(),
                Netmask:   netmask.String(),
                NumHosts:  count,
                FirstIp:   network.String(),   // Approximate
                LastIp:    broadcast.String(), // Approximate
        }, nil</span>
}

func minInt(a, b int) int <span class="cov8" title="1">{
        if a &lt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func maxInt(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (s *Server) GeneratePassword(ctx context.Context, req *pb.PasswordRequest) (*pb.PasswordResponse, error) <span class="cov0" title="0">{
        length := int(req.Length)
        if length &lt;= 0 </span><span class="cov0" title="0">{
                length = 16
        }</span>
        <span class="cov0" title="0">if length &gt; 128 </span><span class="cov0" title="0">{
                length = 128
        }</span>

        <span class="cov0" title="0">count := int(req.Count)
        if count &lt;= 0 </span><span class="cov0" title="0">{
                count = 1
        }</span>
        <span class="cov0" title="0">if count &gt; 100 </span><span class="cov0" title="0">{
                count = 100
        }</span>

        // Build character set
        <span class="cov0" title="0">var charset string
        if req.CustomChars != "" </span><span class="cov0" title="0">{
                charset = req.CustomChars
        }</span> else<span class="cov0" title="0"> {
                if req.Lowercase </span><span class="cov0" title="0">{
                        charset += "abcdefghijklmnopqrstuvwxyz"
                }</span>
                <span class="cov0" title="0">if req.Uppercase </span><span class="cov0" title="0">{
                        charset += "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                }</span>
                <span class="cov0" title="0">if req.Numbers </span><span class="cov0" title="0">{
                        charset += "0123456789"
                }</span>
                <span class="cov0" title="0">if req.Symbols </span><span class="cov0" title="0">{
                        charset += "!@#$%^&amp;*()-_=+[]{}|;:,.&lt;&gt;?"
                }</span>
                // Default to all if nothing selected
                <span class="cov0" title="0">if charset == "" </span><span class="cov0" title="0">{
                        charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&amp;*"
                }</span>
        }

        <span class="cov0" title="0">passwords := make([]string, count)
        for i := 0; i &lt; count; i++ </span><span class="cov0" title="0">{
                password := make([]byte, length)
                for j := 0; j &lt; length; j++ </span><span class="cov0" title="0">{
                        password[j] = charset[gofakeit.Number(0, len(charset)-1)]
                }</span>
                <span class="cov0" title="0">passwords[i] = string(password)</span>
        }

        <span class="cov0" title="0">return &amp;pb.PasswordResponse{Passwords: passwords}, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
